<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libevent: event2/util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libevent
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_db160b4728e6067cf5f9cc14ec42c79d.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;event2/event-config.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
</div>
<p><a href="util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A definition of struct addrinfo for systems that lack it.  <a href="structevutil__addrinfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold information about a monotonic timer.  <a href="structevutil__monotonic__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a69bb004732dec77429200727420ad50c"><td class="memItemLeft" align="right" valign="top"><a id="a69bb004732dec77429200727420ad50c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_MONOT_FALLBACK</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a69bb004732dec77429200727420ad50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb16e8c516213aebb503b6d764139d55"><td class="memItemLeft" align="right" valign="top"><a id="afb16e8c516213aebb503b6d764139d55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_MONOT_PRECISE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afb16e8c516213aebb503b6d764139d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa9b4bfabbeaae5ba828e808938fa2c"><td class="memItemLeft" align="right" valign="top"><a id="a1aa9b4bfabbeaae5ba828e808938fa2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_socklen_t</b>&#160;&#160;&#160;socklen_t</td></tr>
<tr class="separator:a1aa9b4bfabbeaae5ba828e808938fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c6baf0f9ac418407245579ec2a168"><td class="memItemLeft" align="right" valign="top"><a id="aa70c6baf0f9ac418407245579ec2a168"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_CLOSESOCKET</b>(s)&#160;&#160;&#160;<a class="el" href="util_8h.html#a5cfa6c13c62d17570a7d5f6d3541ff5b">evutil_closesocket</a>(s)</td></tr>
<tr class="separator:aa70c6baf0f9ac418407245579ec2a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c296955d33624c18bd4811730caa417"><td class="memItemLeft" align="right" valign="top"><a id="a4c296955d33624c18bd4811730caa417"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4c296955d33624c18bd4811730caa417">evutil_offsetof</a>(type,  field)&#160;&#160;&#160;((off_t)(&amp;((type *)0)-&gt;field))</td></tr>
<tr class="memdesc:a4c296955d33624c18bd4811730caa417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for offsetof on platforms that don't define it. <br /></td></tr>
<tr class="separator:a4c296955d33624c18bd4811730caa417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef0023565082a65020f6e56be59fd0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;&#160;&#160;int</td></tr>
<tr class="memdesc:a7ef0023565082a65020f6e56be59fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type wide enough to hold the output of "socket()" or "accept()".  <a href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">More...</a><br /></td></tr>
<tr class="separator:a7ef0023565082a65020f6e56be59fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42f43db6aaf6e99736329b6611175d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1a42f43db6aaf6e99736329b6611175d">evutil_timercmp</a>(tvp,  uvp,  cmp)</td></tr>
<tr class="memdesc:a1a42f43db6aaf6e99736329b6611175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the tvp is related to uvp according to the relational operator cmp.  <a href="util_8h.html#a1a42f43db6aaf6e99736329b6611175d">More...</a><br /></td></tr>
<tr class="separator:a1a42f43db6aaf6e99736329b6611175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a0aee6129d132a3dd488366352bf2"><td class="memItemLeft" align="right" valign="top"><a id="a393a0aee6129d132a3dd488366352bf2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timerisset</b>(tvp)&#160;&#160;&#160;((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)</td></tr>
<tr class="separator:a393a0aee6129d132a3dd488366352bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard integer types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Integer type definitions for types that are supposed to be defined in the C99-specified stdint.h.</p>
<p>Shamefully, some platforms do not include stdint.h, so we need to replace it. (If you are on a platform like this, your C headers are now over 10 years out of date. You should bug them to do something about this.)</p>
<p>We define:</p>
<dl>
<dt>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t </dt>
<dd>unsigned integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t </dt>
<dd>signed integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_uintptr_t, ev_intptr_t </dt>
<dd>unsigned/signed integers large enough to hold a pointer without loss of bits. </dd>
<dt>ev_ssize_t </dt>
<dd>A signed type of the same size as size_t </dd>
<dt>ev_off_t </dt>
<dd>A signed type typically used to represent offsets within a (potentially large) file </dd>
</dl>
</div></td></tr>
<tr class="memitem:a5943ff8aa2063dd531c7cbc7f20a1e55"><td class="memItemLeft" align="right" valign="top"><a id="a5943ff8aa2063dd531c7cbc7f20a1e55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_int16_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a5943ff8aa2063dd531c7cbc7f20a1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a83fba6bcb61a80774e2533fa1da1b"><td class="memItemLeft" align="right" valign="top"><a id="a91a83fba6bcb61a80774e2533fa1da1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_int32_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a91a83fba6bcb61a80774e2533fa1da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ebbcfd82e30a022792cc0aef0a0049"><td class="memItemLeft" align="right" valign="top"><a id="a22ebbcfd82e30a022792cc0aef0a0049"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_int64_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a22ebbcfd82e30a022792cc0aef0a0049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab642ae86b43a6d75c52811eb686f0837"><td class="memItemLeft" align="right" valign="top"><a id="ab642ae86b43a6d75c52811eb686f0837"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_int8_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:ab642ae86b43a6d75c52811eb686f0837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913c495b489d419353b3d1512505ea2"><td class="memItemLeft" align="right" valign="top"><a id="a4913c495b489d419353b3d1512505ea2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_intptr_t</b>&#160;&#160;&#160;ev_int32_t</td></tr>
<tr class="separator:a4913c495b489d419353b3d1512505ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f968b0d453ef37a233e2d40860296a6"><td class="memItemLeft" align="right" valign="top"><a id="a2f968b0d453ef37a233e2d40860296a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_off_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a2f968b0d453ef37a233e2d40860296a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fce2c187cee381db4bf5276f76a39e8"><td class="memItemLeft" align="right" valign="top"><a id="a9fce2c187cee381db4bf5276f76a39e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_ssize_t</b>&#160;&#160;&#160;ssize_t</td></tr>
<tr class="separator:a9fce2c187cee381db4bf5276f76a39e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc03c0ef4fc4327e373b079528ca049"><td class="memItemLeft" align="right" valign="top"><a id="a9cc03c0ef4fc4327e373b079528ca049"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uint16_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a9cc03c0ef4fc4327e373b079528ca049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b2386e75123100c6179f7f14f8fda2"><td class="memItemLeft" align="right" valign="top"><a id="a43b2386e75123100c6179f7f14f8fda2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uint32_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a43b2386e75123100c6179f7f14f8fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f6d4822116b1492238ea9b0b1469f9"><td class="memItemLeft" align="right" valign="top"><a id="a58f6d4822116b1492238ea9b0b1469f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uint64_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a58f6d4822116b1492238ea9b0b1469f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9052cd1d14b92812de0796d84af5604"><td class="memItemLeft" align="right" valign="top"><a id="ad9052cd1d14b92812de0796d84af5604"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uint8_t</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:ad9052cd1d14b92812de0796d84af5604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf36939a205bd52df25c40fe44b7fd7"><td class="memItemLeft" align="right" valign="top"><a id="a6bf36939a205bd52df25c40fe44b7fd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uintptr_t</b>&#160;&#160;&#160;ev_uint32_t</td></tr>
<tr class="separator:a6bf36939a205bd52df25c40fe44b7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for integer types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros hold the largest or smallest values possible for the ev_[u]int*_t types. </p>
</div></td></tr>
<tr class="memitem:af6271a010b87f8e78edfb3d576d16909"><td class="memItemLeft" align="right" valign="top"><a id="af6271a010b87f8e78edfb3d576d16909"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MAX</b>&#160;&#160;&#160;((ev_int16_t) 0x7fffL)</td></tr>
<tr class="separator:af6271a010b87f8e78edfb3d576d16909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afd44462363963e6cdfc20e10d250a"><td class="memItemLeft" align="right" valign="top"><a id="a10afd44462363963e6cdfc20e10d250a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MIN</b>&#160;&#160;&#160;((-EV_INT16_MAX) - 1)</td></tr>
<tr class="separator:a10afd44462363963e6cdfc20e10d250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb8c4ad3c2b8d2bec82787c9f0eaa3"><td class="memItemLeft" align="right" valign="top"><a id="adbfb8c4ad3c2b8d2bec82787c9f0eaa3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MAX</b>&#160;&#160;&#160;((ev_int32_t) 0x7fffffffL)</td></tr>
<tr class="separator:adbfb8c4ad3c2b8d2bec82787c9f0eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7899efdfa42ebe54093c85fbc35ba8e5"><td class="memItemLeft" align="right" valign="top"><a id="a7899efdfa42ebe54093c85fbc35ba8e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MIN</b>&#160;&#160;&#160;((-EV_INT32_MAX) - 1)</td></tr>
<tr class="separator:a7899efdfa42ebe54093c85fbc35ba8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5b615c4a5ffb69122263c69d8bb091"><td class="memItemLeft" align="right" valign="top"><a id="a7a5b615c4a5ffb69122263c69d8bb091"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MAX</b>&#160;&#160;&#160;((((ev_int64_t) 0x7fffffffL) &lt;&lt; 32) | 0xffffffffL)</td></tr>
<tr class="separator:a7a5b615c4a5ffb69122263c69d8bb091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20073b67f3e9cdda20215246b11c4f6d"><td class="memItemLeft" align="right" valign="top"><a id="a20073b67f3e9cdda20215246b11c4f6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MIN</b>&#160;&#160;&#160;((-EV_INT64_MAX) - 1)</td></tr>
<tr class="separator:a20073b67f3e9cdda20215246b11c4f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae959d5851ca0690f9da6e47fbb8056c9"><td class="memItemLeft" align="right" valign="top"><a id="ae959d5851ca0690f9da6e47fbb8056c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MAX</b>&#160;&#160;&#160;127</td></tr>
<tr class="separator:ae959d5851ca0690f9da6e47fbb8056c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4adcc386a7cb06436af4618301c8b03"><td class="memItemLeft" align="right" valign="top"><a id="aa4adcc386a7cb06436af4618301c8b03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MIN</b>&#160;&#160;&#160;((-EV_INT8_MAX) - 1)</td></tr>
<tr class="separator:aa4adcc386a7cb06436af4618301c8b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85ec3c0198df9bbb370d9c70f1fd2f4"><td class="memItemLeft" align="right" valign="top"><a id="af85ec3c0198df9bbb370d9c70f1fd2f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT16_MAX</b>&#160;&#160;&#160;((ev_uint16_t)0xffffUL)</td></tr>
<tr class="separator:af85ec3c0198df9bbb370d9c70f1fd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815ab1b931ad8d2b11da526b9071282a"><td class="memItemLeft" align="right" valign="top"><a id="a815ab1b931ad8d2b11da526b9071282a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT32_MAX</b>&#160;&#160;&#160;((ev_uint32_t)0xffffffffUL)</td></tr>
<tr class="separator:a815ab1b931ad8d2b11da526b9071282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cff4b5f64165a133fd51d3004964db"><td class="memItemLeft" align="right" valign="top"><a id="a34cff4b5f64165a133fd51d3004964db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT64_MAX</b>&#160;&#160;&#160;((((ev_uint64_t)0xffffffffUL) &lt;&lt; 32) | 0xffffffffUL)</td></tr>
<tr class="separator:a34cff4b5f64165a133fd51d3004964db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af5a509193ad75cdd20e77a8422d84d"><td class="memItemLeft" align="right" valign="top"><a id="a8af5a509193ad75cdd20e77a8422d84d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT8_MAX</b>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a8af5a509193ad75cdd20e77a8422d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for SIZE_T and SSIZE_T</div></td></tr>
<tr class="memitem:a2b6a9c2fa6a1ba42d79e2f9118f9670c"><td class="memItemLeft" align="right" valign="top"><a id="a2b6a9c2fa6a1ba42d79e2f9118f9670c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_SIZE_MAX</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a2b6a9c2fa6a1ba42d79e2f9118f9670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142028f0a0d7248168a3aaca652851c3"><td class="memItemLeft" align="right" valign="top"><a id="a142028f0a0d7248168a3aaca652851c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_SSIZE_MAX</b>&#160;&#160;&#160;...</td></tr>
<tr class="separator:a142028f0a0d7248168a3aaca652851c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e6c7724ce1f7e0562d6e24021acb10"><td class="memItemLeft" align="right" valign="top"><a id="a59e6c7724ce1f7e0562d6e24021acb10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_SSIZE_MIN</b>&#160;&#160;&#160;((-EV_SSIZE_MAX) - 1)</td></tr>
<tr class="separator:a59e6c7724ce1f7e0562d6e24021acb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Socket error functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are needed for making programs compatible between Windows and Unix-like platforms.</p>
<p>You see, Winsock handles socket errors differently from the rest of the world. Elsewhere, a socket error is like any other error and is stored in errno. But winsock functions require you to retrieve the error with a special function, and don't let you use strerror for the error codes. And handling EWOULDBLOCK is ... different. </p>
</div></td></tr>
<tr class="memitem:a3c79bbe4f3ac17dd484e6d5c262b17df"><td class="memItemLeft" align="right" valign="top"><a id="a3c79bbe4f3ac17dd484e6d5c262b17df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_INVALID_SOCKET</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a3c79bbe4f3ac17dd484e6d5c262b17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b4fae7790599f7b58e8c269f6b29d8"><td class="memItemLeft" align="right" valign="top"><a id="ae8b4fae7790599f7b58e8c269f6b29d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae8b4fae7790599f7b58e8c269f6b29d8">EVUTIL_SET_SOCKET_ERROR</a>(errcode)&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:ae8b4fae7790599f7b58e8c269f6b29d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the most recent socket error with errcode. <br /></td></tr>
<tr class="separator:ae8b4fae7790599f7b58e8c269f6b29d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a94a2e72982e708333486cf72aab941"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9a94a2e72982e708333486cf72aab941">EVUTIL_SOCKET_ERROR</a>()&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:a9a94a2e72982e708333486cf72aab941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the most recent socket error.  <a href="util_8h.html#a9a94a2e72982e708333486cf72aab941">More...</a><br /></td></tr>
<tr class="separator:a9a94a2e72982e708333486cf72aab941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ea5ef81ddcfb299e4867d362ad8654"><td class="memItemLeft" align="right" valign="top"><a id="ad5ea5ef81ddcfb299e4867d362ad8654"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad5ea5ef81ddcfb299e4867d362ad8654">evutil_socket_error_to_string</a>(errcode)&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:ad5ea5ef81ddcfb299e4867d362ad8654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a socket error to a string. <br /></td></tr>
<tr class="separator:ad5ea5ef81ddcfb299e4867d362ad8654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f952fb0f16b057d931fd38ee9bdf5e"><td class="memItemLeft" align="right" valign="top"><a id="a28f952fb0f16b057d931fd38ee9bdf5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a28f952fb0f16b057d931fd38ee9bdf5e">evutil_socket_geterror</a>(sock)&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:a28f952fb0f16b057d931fd38ee9bdf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the most recent socket error to occur on sock. <br /></td></tr>
<tr class="separator:a28f952fb0f16b057d931fd38ee9bdf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulation macros for struct timeval.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>!_WIN32</p>
<p>We define replacements for timeradd, timersub, timerclear, timercmp, and timerisset. </p>
</div></td></tr>
<tr class="memitem:a6182f91a8aede88fac748b3f424cbb6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timeradd</b>(tvp,  uvp,  vvp)</td></tr>
<tr class="separator:a6182f91a8aede88fac748b3f424cbb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4999b82eab8bcb8becc8cb079341a0"><td class="memItemLeft" align="right" valign="top"><a id="add4999b82eab8bcb8becc8cb079341a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timerclear</b>(tvp)&#160;&#160;&#160;(tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</td></tr>
<tr class="separator:add4999b82eab8bcb8becc8cb079341a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75cdb8eae7b33eac738c46356967399"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timersub</b>(tvp,  uvp,  vvp)</td></tr>
<tr class="separator:ab75cdb8eae7b33eac738c46356967399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">evutil_getaddrinfo() error codes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These values are possible error codes for <a class="el" href="util_8h.html#a0f36c2fc48c644a4f56347a25c585cc9" title="This function clones getaddrinfo for systems that don&#39;t have it.">evutil_getaddrinfo()</a> and related functions. </p>
</div></td></tr>
<tr class="memitem:a1162c61313f61eff48a9533a3309f739"><td class="memItemLeft" align="right" valign="top"><a id="a1162c61313f61eff48a9533a3309f739"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ADDRCONFIG</b>&#160;&#160;&#160;0x40000</td></tr>
<tr class="separator:a1162c61313f61eff48a9533a3309f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437bacd5a8915b541a3e38c965932297"><td class="memItemLeft" align="right" valign="top"><a id="a437bacd5a8915b541a3e38c965932297"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ALL</b>&#160;&#160;&#160;0x20000</td></tr>
<tr class="separator:a437bacd5a8915b541a3e38c965932297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1fbbc2f3b038e60fd97a620bff9230"><td class="memItemLeft" align="right" valign="top"><a id="a1b1fbbc2f3b038e60fd97a620bff9230"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_CANONNAME</b>&#160;&#160;&#160;0x2000</td></tr>
<tr class="separator:a1b1fbbc2f3b038e60fd97a620bff9230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a3766f56a33a6d845cfd0dba1890d"><td class="memItemLeft" align="right" valign="top"><a id="a145a3766f56a33a6d845cfd0dba1890d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICHOST</b>&#160;&#160;&#160;0x4000</td></tr>
<tr class="separator:a145a3766f56a33a6d845cfd0dba1890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067c788a683f74e43e87098a68b37e69"><td class="memItemLeft" align="right" valign="top"><a id="a067c788a683f74e43e87098a68b37e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICSERV</b>&#160;&#160;&#160;0x8000</td></tr>
<tr class="separator:a067c788a683f74e43e87098a68b37e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2611f48d74207f6e996189e71ca9742f"><td class="memItemLeft" align="right" valign="top"><a id="a2611f48d74207f6e996189e71ca9742f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_PASSIVE</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="separator:a2611f48d74207f6e996189e71ca9742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc6a3beb4ecf5b653a871949a49b53a"><td class="memItemLeft" align="right" valign="top"><a id="abbc6a3beb4ecf5b653a871949a49b53a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_V4MAPPED</b>&#160;&#160;&#160;0x10000</td></tr>
<tr class="separator:abbc6a3beb4ecf5b653a871949a49b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1a2e7213ceab1be80a752ec8cbd109"><td class="memItemLeft" align="right" valign="top"><a id="aaf1a2e7213ceab1be80a752ec8cbd109"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_ADDRFAMILY</b>&#160;&#160;&#160;-901</td></tr>
<tr class="separator:aaf1a2e7213ceab1be80a752ec8cbd109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cb726c0bf1ff8907dfc3b4171742ac"><td class="memItemLeft" align="right" valign="top"><a id="ae1cb726c0bf1ff8907dfc3b4171742ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_AGAIN</b>&#160;&#160;&#160;-902</td></tr>
<tr class="separator:ae1cb726c0bf1ff8907dfc3b4171742ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f1ed6215f25714f371551cb7467ad7"><td class="memItemLeft" align="right" valign="top"><a id="ac5f1ed6215f25714f371551cb7467ad7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_BADFLAGS</b>&#160;&#160;&#160;-903</td></tr>
<tr class="separator:ac5f1ed6215f25714f371551cb7467ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34127164b338d82707034566b100b4cb"><td class="memItemLeft" align="right" valign="top"><a id="a34127164b338d82707034566b100b4cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_CANCEL</b>&#160;&#160;&#160;-90001</td></tr>
<tr class="separator:a34127164b338d82707034566b100b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76916ba557e677dafe9c1fd7da89f2b3"><td class="memItemLeft" align="right" valign="top"><a id="a76916ba557e677dafe9c1fd7da89f2b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAIL</b>&#160;&#160;&#160;-904</td></tr>
<tr class="separator:a76916ba557e677dafe9c1fd7da89f2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5ae5495d39cb471ef5403c2823ab4"><td class="memItemLeft" align="right" valign="top"><a id="a0df5ae5495d39cb471ef5403c2823ab4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAMILY</b>&#160;&#160;&#160;-905</td></tr>
<tr class="separator:a0df5ae5495d39cb471ef5403c2823ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03351808979dfac04060773ebfd3c06b"><td class="memItemLeft" align="right" valign="top"><a id="a03351808979dfac04060773ebfd3c06b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_MEMORY</b>&#160;&#160;&#160;-906</td></tr>
<tr class="separator:a03351808979dfac04060773ebfd3c06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7b69a78006c0f48d88f88e9b55334b"><td class="memItemLeft" align="right" valign="top"><a id="a1d7b69a78006c0f48d88f88e9b55334b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NODATA</b>&#160;&#160;&#160;-907</td></tr>
<tr class="separator:a1d7b69a78006c0f48d88f88e9b55334b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100c4d4e222d5cdfa2aebcf3a0140e9"><td class="memItemLeft" align="right" valign="top"><a id="ab100c4d4e222d5cdfa2aebcf3a0140e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NONAME</b>&#160;&#160;&#160;-908</td></tr>
<tr class="separator:ab100c4d4e222d5cdfa2aebcf3a0140e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc1d8d4eead1bc0e15eaae2edaf668"><td class="memItemLeft" align="right" valign="top"><a id="ab2cc1d8d4eead1bc0e15eaae2edaf668"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SERVICE</b>&#160;&#160;&#160;-909</td></tr>
<tr class="separator:ab2cc1d8d4eead1bc0e15eaae2edaf668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30b335f48757b2ba10da69f80a87a46"><td class="memItemLeft" align="right" valign="top"><a id="ac30b335f48757b2ba10da69f80a87a46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SOCKTYPE</b>&#160;&#160;&#160;-910</td></tr>
<tr class="separator:ac30b335f48757b2ba10da69f80a87a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03273ded49de60ab08e489b7d5d5e17e"><td class="memItemLeft" align="right" valign="top"><a id="a03273ded49de60ab08e489b7d5d5e17e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SYSTEM</b>&#160;&#160;&#160;-911</td></tr>
<tr class="separator:a03273ded49de60ab08e489b7d5d5e17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae46d8f8407906b79216f9be88803126"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aae46d8f8407906b79216f9be88803126">evutil_ascii_strcasecmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:aae46d8f8407906b79216f9be88803126"><td class="mdescLeft">&#160;</td><td class="mdescRight">As strcasecmp, but always compares the characters in locale-independent ASCII.  <a href="util_8h.html#aae46d8f8407906b79216f9be88803126">More...</a><br /></td></tr>
<tr class="separator:aae46d8f8407906b79216f9be88803126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b44d66883df5bfed32c9ac6df93aac"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a03b44d66883df5bfed32c9ac6df93aac">evutil_ascii_strncasecmp</a> (const char *str1, const char *str2, size_t n)</td></tr>
<tr class="memdesc:a03b44d66883df5bfed32c9ac6df93aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">As strncasecmp, but always compares the characters in locale-independent ASCII.  <a href="util_8h.html#a03b44d66883df5bfed32c9ac6df93aac">More...</a><br /></td></tr>
<tr class="separator:a03b44d66883df5bfed32c9ac6df93aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfa6c13c62d17570a7d5f6d3541ff5b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5cfa6c13c62d17570a7d5f6d3541ff5b">evutil_closesocket</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a5cfa6c13c62d17570a7d5f6d3541ff5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the platform-specific call needed to close a socket returned from socket() or accept().  <a href="util_8h.html#a5cfa6c13c62d17570a7d5f6d3541ff5b">More...</a><br /></td></tr>
<tr class="separator:a5cfa6c13c62d17570a7d5f6d3541ff5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab486d1e10fd1e3102b4e53beed8d9baa"><td class="memItemLeft" align="right" valign="top"><a id="ab486d1e10fd1e3102b4e53beed8d9baa"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa">evutil_configure_monotonic_time</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer, int flags)</td></tr>
<tr class="memdesc:ab486d1e10fd1e3102b4e53beed8d9baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a>; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK. <br /></td></tr>
<tr class="separator:ab486d1e10fd1e3102b4e53beed8d9baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2f7f9996a6ff28db2aeb8ac8a58187"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9d2f7f9996a6ff28db2aeb8ac8a58187">evutil_date_rfc1123</a> (char *date, const size_t datelen, const struct tm *tm)</td></tr>
<tr class="memdesc:a9d2f7f9996a6ff28db2aeb8ac8a58187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a date string using RFC 1123 format (used in HTTP).  <a href="util_8h.html#a9d2f7f9996a6ff28db2aeb8ac8a58187">More...</a><br /></td></tr>
<tr class="separator:a9d2f7f9996a6ff28db2aeb8ac8a58187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a472b3afc5cef1e6b1c9912604381b"><td class="memItemLeft" align="right" valign="top"><a id="a58a472b3afc5cef1e6b1c9912604381b"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a58a472b3afc5cef1e6b1c9912604381b">evutil_freeaddrinfo</a> (struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *ai)</td></tr>
<tr class="memdesc:a58a472b3afc5cef1e6b1c9912604381b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. <br /></td></tr>
<tr class="separator:a58a472b3afc5cef1e6b1c9912604381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef926a2044f1b23807f7f8387dc6d2e5"><td class="memItemLeft" align="right" valign="top"><a id="aef926a2044f1b23807f7f8387dc6d2e5"></a>
const EVENT2_EXPORT_SYMBOL char *&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_gai_strerror</b> (int err)</td></tr>
<tr class="separator:aef926a2044f1b23807f7f8387dc6d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f36c2fc48c644a4f56347a25c585cc9"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0f36c2fc48c644a4f56347a25c585cc9">evutil_getaddrinfo</a> (const char *nodename, const char *servname, const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *hints_in, struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **res)</td></tr>
<tr class="memdesc:a0f36c2fc48c644a4f56347a25c585cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clones getaddrinfo for systems that don't have it.  <a href="util_8h.html#a0f36c2fc48c644a4f56347a25c585cc9">More...</a><br /></td></tr>
<tr class="separator:a0f36c2fc48c644a4f56347a25c585cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe94df86960981b69411f20c0c5235dc"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abe94df86960981b69411f20c0c5235dc">evutil_gettime_monotonic</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer, struct timeval *tp)</td></tr>
<tr class="memdesc:abe94df86960981b69411f20c0c5235dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current monotonic time from a struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a> previously configured with <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa" title="Set up a struct evutil_monotonic_timer; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK.">evutil_configure_monotonic_time()</a>.  <a href="util_8h.html#abe94df86960981b69411f20c0c5235dc">More...</a><br /></td></tr>
<tr class="separator:abe94df86960981b69411f20c0c5235dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12557f3d4c54dd80fc13f07b28ec20fd"><td class="memItemLeft" align="right" valign="top"><a id="a12557f3d4c54dd80fc13f07b28ec20fd"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_gettimeofday</b> (struct timeval *tv, struct timezone *tz)</td></tr>
<tr class="separator:a12557f3d4c54dd80fc13f07b28ec20fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa98d48bdd6ad06c1fd013a44621d567"><td class="memItemLeft" align="right" valign="top"><a id="afa98d48bdd6ad06c1fd013a44621d567"></a>
const EVENT2_EXPORT_SYMBOL char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#afa98d48bdd6ad06c1fd013a44621d567">evutil_inet_ntop</a> (int af, const void *src, char *dst, size_t len)</td></tr>
<tr class="memdesc:afa98d48bdd6ad06c1fd013a44621d567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for inet_ntop for platforms which lack it. <br /></td></tr>
<tr class="separator:afa98d48bdd6ad06c1fd013a44621d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4065af1c9c995010ef7df66154c313b2"><td class="memItemLeft" align="right" valign="top"><a id="a4065af1c9c995010ef7df66154c313b2"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4065af1c9c995010ef7df66154c313b2">evutil_inet_pton</a> (int af, const char *src, void *dst)</td></tr>
<tr class="memdesc:a4065af1c9c995010ef7df66154c313b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for inet_pton for platforms which lack it. <br /></td></tr>
<tr class="separator:a4065af1c9c995010ef7df66154c313b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad361aa5727c88f05633a9032ad8c850f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad361aa5727c88f05633a9032ad8c850f">evutil_make_listen_socket_ipv6only</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:ad361aa5727c88f05633a9032ad8c850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ipv6 only bind socket option to make listener work only in ipv6 sockets.  <a href="util_8h.html#ad361aa5727c88f05633a9032ad8c850f">More...</a><br /></td></tr>
<tr class="separator:ad361aa5727c88f05633a9032ad8c850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e18b7861ed856bde592257f6b6e11"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7a8e18b7861ed856bde592257f6b6e11">evutil_make_listen_socket_reuseable</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a7a8e18b7861ed856bde592257f6b6e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do platform-specific operations to make a listener socket reusable.  <a href="util_8h.html#a7a8e18b7861ed856bde592257f6b6e11">More...</a><br /></td></tr>
<tr class="separator:a7a8e18b7861ed856bde592257f6b6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e68f77ce876ceecc6fb65f2dbe506"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9e4e68f77ce876ceecc6fb65f2dbe506">evutil_make_listen_socket_reuseable_port</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a9e4e68f77ce876ceecc6fb65f2dbe506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do platform-specific operations to make a listener port reusable.  <a href="util_8h.html#a9e4e68f77ce876ceecc6fb65f2dbe506">More...</a><br /></td></tr>
<tr class="separator:a9e4e68f77ce876ceecc6fb65f2dbe506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edc3874139e863f61edf6c705030430"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7edc3874139e863f61edf6c705030430">evutil_make_socket_closeonexec</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a7edc3874139e863f61edf6c705030430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions.  <a href="util_8h.html#a7edc3874139e863f61edf6c705030430">More...</a><br /></td></tr>
<tr class="separator:a7edc3874139e863f61edf6c705030430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f2384311baf5d7308c7ab079f9b84"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4f8f2384311baf5d7308c7ab079f9b84">evutil_make_socket_nonblocking</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a4f8f2384311baf5d7308c7ab079f9b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do platform-specific operations as needed to make a socket nonblocking.  <a href="util_8h.html#a4f8f2384311baf5d7308c7ab079f9b84">More...</a><br /></td></tr>
<tr class="separator:a4f8f2384311baf5d7308c7ab079f9b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b1fc98edeac63efc8b13c4f822a0d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a988b1fc98edeac63efc8b13c4f822a0d">evutil_make_tcp_listen_socket_deferred</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="memdesc:a988b1fc98edeac63efc8b13c4f822a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do platform-specific operations, if possible, to make a tcp listener socket defer accept()s until there is data to read.  <a href="util_8h.html#a988b1fc98edeac63efc8b13c4f822a0d">More...</a><br /></td></tr>
<tr class="separator:a988b1fc98edeac63efc8b13c4f822a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2874062ff988293cd4e40b220933e209"><td class="memItemLeft" align="right" valign="top"><a id="a2874062ff988293cd4e40b220933e209"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a2874062ff988293cd4e40b220933e209">evutil_monotonic_timer_free</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer)</td></tr>
<tr class="memdesc:a2874062ff988293cd4e40b220933e209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a> that was allocated using <a class="el" href="util_8h.html#a87b00e2754d908ba05c5aa8e9c8e4f28" title="Allocate a new struct evutil_monotonic_timer for use with the evutil_configure_monotonic_time() and e...">evutil_monotonic_timer_new()</a>. <br /></td></tr>
<tr class="separator:a2874062ff988293cd4e40b220933e209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b00e2754d908ba05c5aa8e9c8e4f28"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a87b00e2754d908ba05c5aa8e9c8e4f28">evutil_monotonic_timer_new</a> (void)</td></tr>
<tr class="memdesc:a87b00e2754d908ba05c5aa8e9c8e4f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a> for use with the <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa" title="Set up a struct evutil_monotonic_timer; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK.">evutil_configure_monotonic_time()</a> and <a class="el" href="util_8h.html#abe94df86960981b69411f20c0c5235dc" title="Query the current monotonic time from a struct evutil_monotonic_timer previously configured with evut...">evutil_gettime_monotonic()</a> functions.  <a href="util_8h.html#a87b00e2754d908ba05c5aa8e9c8e4f28">More...</a><br /></td></tr>
<tr class="separator:a87b00e2754d908ba05c5aa8e9c8e4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4f315d5c40c4f604f6c9ae694a684"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a97d4f315d5c40c4f604f6c9ae694a684">evutil_parse_sockaddr_port</a> (const char *str, struct sockaddr *out, int *outlen)</td></tr>
<tr class="memdesc:a97d4f315d5c40c4f604f6c9ae694a684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IPv4 or IPv6 address, with optional port, from a string.  <a href="util_8h.html#a97d4f315d5c40c4f604f6c9ae694a684">More...</a><br /></td></tr>
<tr class="separator:a97d4f315d5c40c4f604f6c9ae694a684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5b7d22b368ffdd6ed77838bf4fcea6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3b5b7d22b368ffdd6ed77838bf4fcea6">evutil_secure_rng_add_bytes</a> (const char *dat, size_t datlen)</td></tr>
<tr class="memdesc:a3b5b7d22b368ffdd6ed77838bf4fcea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the random number generator with extra random bytes.  <a href="util_8h.html#a3b5b7d22b368ffdd6ed77838bf4fcea6">More...</a><br /></td></tr>
<tr class="separator:a3b5b7d22b368ffdd6ed77838bf4fcea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0836ed5d00ccab1957419a07b7acbb56"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0836ed5d00ccab1957419a07b7acbb56">evutil_secure_rng_get_bytes</a> (void *buf, size_t n)</td></tr>
<tr class="memdesc:a0836ed5d00ccab1957419a07b7acbb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate n bytes of secure pseudorandom data, and store them in buf.  <a href="util_8h.html#a0836ed5d00ccab1957419a07b7acbb56">More...</a><br /></td></tr>
<tr class="separator:a0836ed5d00ccab1957419a07b7acbb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffe53dcbe32ad55f1582a0da358ac0"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0">evutil_secure_rng_init</a> (void)</td></tr>
<tr class="memdesc:a49ffe53dcbe32ad55f1582a0da358ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the secure random number generator if needed, and return 0 on success or -1 on failure.  <a href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0">More...</a><br /></td></tr>
<tr class="separator:a49ffe53dcbe32ad55f1582a0da358ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4544ddceb4e20c8c52985641ca829b7e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4544ddceb4e20c8c52985641ca829b7e">evutil_secure_rng_set_urandom_device_file</a> (char *fname)</td></tr>
<tr class="memdesc:a4544ddceb4e20c8c52985641ca829b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a filename to use in place of /dev/urandom for seeding the secure PRNG.  <a href="util_8h.html#a4544ddceb4e20c8c52985641ca829b7e">More...</a><br /></td></tr>
<tr class="separator:a4544ddceb4e20c8c52985641ca829b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198e8db3626746515792e28b1380be67"><td class="memItemLeft" align="right" valign="top"><a id="a198e8db3626746515792e28b1380be67"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a198e8db3626746515792e28b1380be67">evutil_snprintf</a> (char *buf, size_t buflen, const char *format,...)</td></tr>
<tr class="memdesc:a198e8db3626746515792e28b1380be67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for snprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. <br /></td></tr>
<tr class="separator:a198e8db3626746515792e28b1380be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ad1074f1effe2dbfa18b3f44b589f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7b5ad1074f1effe2dbfa18b3f44b589f">evutil_sockaddr_cmp</a> (const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)</td></tr>
<tr class="memdesc:a7b5ad1074f1effe2dbfa18b3f44b589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2.  <a href="util_8h.html#a7b5ad1074f1effe2dbfa18b3f44b589f">More...</a><br /></td></tr>
<tr class="separator:a7b5ad1074f1effe2dbfa18b3f44b589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d08d44d7b2823a9c4e218c69160d9ab"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0d08d44d7b2823a9c4e218c69160d9ab">evutil_socketpair</a> (int d, int type, int protocol, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sv[2])</td></tr>
<tr class="memdesc:a0d08d44d7b2823a9c4e218c69160d9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create two new sockets that are connected to each other.  <a href="util_8h.html#a0d08d44d7b2823a9c4e218c69160d9ab">More...</a><br /></td></tr>
<tr class="separator:a0d08d44d7b2823a9c4e218c69160d9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9175e63729c256eb2646e11e8211f4f7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL ev_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9175e63729c256eb2646e11e8211f4f7">evutil_strtoll</a> (const char *s, char **endptr, int base)</td></tr>
<tr class="memdesc:a9175e63729c256eb2646e11e8211f4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a 64-bit value from a string.  <a href="util_8h.html#a9175e63729c256eb2646e11e8211f4f7">More...</a><br /></td></tr>
<tr class="separator:a9175e63729c256eb2646e11e8211f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bbdc509d150e5dfac1f74dd4e4c212"><td class="memItemLeft" align="right" valign="top"><a id="a30bbdc509d150e5dfac1f74dd4e4c212"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a30bbdc509d150e5dfac1f74dd4e4c212">evutil_vsnprintf</a> (char *buf, size_t buflen, const char *format, va_list ap)</td></tr>
<tr class="memdesc:a30bbdc509d150e5dfac1f74dd4e4c212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for vsnprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. <br /></td></tr>
<tr class="separator:a30bbdc509d150e5dfac1f74dd4e4c212"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common convenience functions for cross-platform portability and related socket manipulations. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9a94a2e72982e708333486cf72aab941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a94a2e72982e708333486cf72aab941">&#9670;&nbsp;</a></span>EVUTIL_SOCKET_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVUTIL_SOCKET_ERROR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;...</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the most recent socket error. </p>
<p>Not idempotent on all platforms. </p>

</div>
</div>
<a id="a7ef0023565082a65020f6e56be59fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef0023565082a65020f6e56be59fd0b">&#9670;&nbsp;</a></span>evutil_socket_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_socket_t&#160;&#160;&#160;int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type wide enough to hold the output of "socket()" or "accept()". </p>
<p>On Windows, this is an intptr_t; elsewhere, it is an int. </p>

</div>
</div>
<a id="a6182f91a8aede88fac748b3f424cbb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6182f91a8aede88fac748b3f424cbb6d">&#9670;&nbsp;</a></span>evutil_timeradd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timeradd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vvp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                \</div>
<div class="line">        (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec + (uvp)-&gt;tv_sec;      \</div>
<div class="line">        (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec + (uvp)-&gt;tv_usec;       \</div>
<div class="line">        if ((vvp)-&gt;tv_usec &gt;= 1000000) {            \</div>
<div class="line">            (vvp)-&gt;tv_sec++;                \</div>
<div class="line">            (vvp)-&gt;tv_usec -= 1000000;          \</div>
<div class="line">        }                           \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a42f43db6aaf6e99736329b6611175d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a42f43db6aaf6e99736329b6611175d">&#9670;&nbsp;</a></span>evutil_timercmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timercmp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?             \</div>
<div class="line">     ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) :              \</div>
<div class="line">     ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))</div>
</div><!-- fragment -->
<p>Return true iff the tvp is related to uvp according to the relational operator cmp. </p>
<p>Recognized values for cmp are ==, &lt;=, &lt;, &gt;=, and &gt;. </p>

</div>
</div>
<a id="ab75cdb8eae7b33eac738c46356967399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75cdb8eae7b33eac738c46356967399">&#9670;&nbsp;</a></span>evutil_timersub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timersub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vvp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                \</div>
<div class="line">        (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec;      \</div>
<div class="line">        (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec;   \</div>
<div class="line">        if ((vvp)-&gt;tv_usec &lt; 0) {               \</div>
<div class="line">            (vvp)-&gt;tv_sec--;                \</div>
<div class="line">            (vvp)-&gt;tv_usec += 1000000;          \</div>
<div class="line">        }                           \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae46d8f8407906b79216f9be88803126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae46d8f8407906b79216f9be88803126">&#9670;&nbsp;</a></span>evutil_ascii_strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_ascii_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As strcasecmp, but always compares the characters in locale-independent ASCII. </p>
<p>That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a id="a03b44d66883df5bfed32c9ac6df93aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b44d66883df5bfed32c9ac6df93aac">&#9670;&nbsp;</a></span>evutil_ascii_strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_ascii_strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As strncasecmp, but always compares the characters in locale-independent ASCII. </p>
<p>That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a id="a5cfa6c13c62d17570a7d5f6d3541ff5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfa6c13c62d17570a7d5f6d3541ff5b">&#9670;&nbsp;</a></span>evutil_closesocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_closesocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the platform-specific call needed to close a socket returned from socket() or accept(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (whether the operation is supported or not), -1 on failure </dd></dl>

</div>
</div>
<a id="a9d2f7f9996a6ff28db2aeb8ac8a58187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2f7f9996a6ff28db2aeb8ac8a58187">&#9670;&nbsp;</a></span>evutil_date_rfc1123()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_date_rfc1123 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>datelen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a date string using RFC 1123 format (used in HTTP). </p>
<p>If <code>tm</code> is NULL, current system's time will be used. The number of characters written will be returned. One should check if the return value is smaller than <code>datelen</code> to check if the result is truncated or not. </p>

</div>
</div>
<a id="a0f36c2fc48c644a4f56347a25c585cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f36c2fc48c644a4f56347a25c585cc9">&#9670;&nbsp;</a></span>evutil_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>servname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&#160;</td>
          <td class="paramname"><em>hints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clones getaddrinfo for systems that don't have it. </p>
<p>For full details, see RFC 3493, section 6.1.</p>
<p>Limitations:</p><ul>
<li>When the system has no getaddrinfo, we fall back to gethostbyname_r or gethostbyname, with their attendant issues.</li>
<li>The AI_V4MAPPED and AI_ALL flags are not currently implemented.</li>
</ul>
<p>For a nonblocking variant, see evdns_getaddrinfo. </p>

</div>
</div>
<a id="abe94df86960981b69411f20c0c5235dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe94df86960981b69411f20c0c5235dc">&#9670;&nbsp;</a></span>evutil_gettime_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_gettime_monotonic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the current monotonic time from a struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a> previously configured with <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa" title="Set up a struct evutil_monotonic_timer; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK.">evutil_configure_monotonic_time()</a>. </p>
<p>Monotonic time is guaranteed never to run in reverse, but is not necessarily epoch- based, or relative to any other definite point. Use it to make reliable measurements of elapsed time between events even when the system time may be changed.</p>
<p>It is not safe to use this funtion on the same timer from multiple threads. </p>

</div>
</div>
<a id="ad361aa5727c88f05633a9032ad8c850f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad361aa5727c88f05633a9032ad8c850f">&#9670;&nbsp;</a></span>evutil_make_listen_socket_ipv6only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_listen_socket_ipv6only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ipv6 only bind socket option to make listener work only in ipv6 sockets. </p>
<p>According to RFC3493 and most Linux distributions, default value for the sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not possible to bind same port from different IPv4 and IPv6 handlers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make in ipv6only working mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a7a8e18b7861ed856bde592257f6b6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e18b7861ed856bde592257f6b6e11">&#9670;&nbsp;</a></span>evutil_make_listen_socket_reuseable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_listen_socket_reuseable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do platform-specific operations to make a listener socket reusable. </p>
<p>Specifically, we want to make sure that another program will be able to bind this address right after we've closed the listener.</p>
<p>This differs from Windows's interpretation of "reusable", which allows multiple listeners to bind the same address at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make reusable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a9e4e68f77ce876ceecc6fb65f2dbe506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e68f77ce876ceecc6fb65f2dbe506">&#9670;&nbsp;</a></span>evutil_make_listen_socket_reuseable_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_listen_socket_reuseable_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do platform-specific operations to make a listener port reusable. </p>
<p>Specifically, we want to make sure that multiple programs which also set the same socket option will be able to bind, listen at the same time.</p>
<p>This is a feature available only to Linux 3.9+</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make reusable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a7edc3874139e863f61edf6c705030430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edc3874139e863f61edf6c705030430">&#9670;&nbsp;</a></span>evutil_make_socket_closeonexec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_socket_closeonexec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a4f8f2384311baf5d7308c7ab079f9b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8f2384311baf5d7308c7ab079f9b84">&#9670;&nbsp;</a></span>evutil_make_socket_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_socket_nonblocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do platform-specific operations as needed to make a socket nonblocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make nonblocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a988b1fc98edeac63efc8b13c4f822a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988b1fc98edeac63efc8b13c4f822a0d">&#9670;&nbsp;</a></span>evutil_make_tcp_listen_socket_deferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_tcp_listen_socket_deferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do platform-specific operations, if possible, to make a tcp listener socket defer accept()s until there is data to read. </p>
<p>Not all platforms support this. You don't want to do this for every listener socket: only the ones that implement a protocol where the client transmits before the server needs to respond.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The listening socket to to make deferred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (whether the operation is supported or not), -1 on failure </dd></dl>

</div>
</div>
<a id="a87b00e2754d908ba05c5aa8e9c8e4f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b00e2754d908ba05c5aa8e9c8e4f28">&#9670;&nbsp;</a></span>evutil_monotonic_timer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a>* evutil_monotonic_timer_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new struct <a class="el" href="structevutil__monotonic__timer.html" title="Structure to hold information about a monotonic timer.">evutil_monotonic_timer</a> for use with the <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa" title="Set up a struct evutil_monotonic_timer; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK.">evutil_configure_monotonic_time()</a> and <a class="el" href="util_8h.html#abe94df86960981b69411f20c0c5235dc" title="Query the current monotonic time from a struct evutil_monotonic_timer previously configured with evut...">evutil_gettime_monotonic()</a> functions. </p>
<p>You must configure the timer with <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa" title="Set up a struct evutil_monotonic_timer; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK.">evutil_configure_monotonic_time()</a> before using it. </p>

</div>
</div>
<a id="a97d4f315d5c40c4f604f6c9ae694a684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d4f315d5c40c4f604f6c9ae694a684">&#9670;&nbsp;</a></span>evutil_parse_sockaddr_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_parse_sockaddr_port </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IPv4 or IPv6 address, with optional port, from a string. </p>
<p>Recognized formats are:</p><ul>
<li>[IPv6Address]:port</li>
<li>[IPv6Address]</li>
<li>IPv6Address</li>
<li>IPv4Address:port</li>
<li>IPv4Address</li>
</ul>
<p>If no port is specified, the port in the output is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">out</td><td>A struct sockaddr to hold the result. This should probably be a struct sockaddr_storage. </td></tr>
    <tr><td class="paramname">outlen</td><td>A pointer to the number of bytes that that 'out' can safely hold. Set to the number of bytes used in 'out' on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the address is not well-formed, if the port is out of range, or if out is not large enough to hold the result. Otherwise returns 0 on success. </dd></dl>

</div>
</div>
<a id="a3b5b7d22b368ffdd6ed77838bf4fcea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5b7d22b368ffdd6ed77838bf4fcea6">&#9670;&nbsp;</a></span>evutil_secure_rng_add_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_secure_rng_add_bytes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seed the random number generator with extra random bytes. </p>
<p>You should almost never need to call this function; it should be sufficient to invoke <a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0" title="Seed the secure random number generator if needed, and return 0 on success or -1 on failure.">evutil_secure_rng_init()</a>, or let Libevent take care of calling <a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0" title="Seed the secure random number generator if needed, and return 0 on success or -1 on failure.">evutil_secure_rng_init()</a> on its own.</p>
<p>If you call this function as a <em>replacement</em> for the regular entropy sources, then you need to be sure that your input contains a fairly large amount of strong entropy. Doing so is notoriously hard: most people who try get it wrong. Watch out!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>a buffer full of a strong source of random numbers </td></tr>
    <tr><td class="paramname">datlen</td><td>the number of bytes to read from datlen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0836ed5d00ccab1957419a07b7acbb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0836ed5d00ccab1957419a07b7acbb56">&#9670;&nbsp;</a></span>evutil_secure_rng_get_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_secure_rng_get_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate n bytes of secure pseudorandom data, and store them in buf. </p>
<p>Current versions of Libevent use an ARC4-based random number generator, seeded using the platform's entropy source (/dev/urandom on Unix-like systems; CryptGenRandom on Windows). This is not actually as secure as it should be: ARC4 is a pretty lousy cipher, and the current implementation provides only rudimentary prediction- and backtracking-resistance. Don't use this for serious cryptographic applications. </p>

</div>
</div>
<a id="a49ffe53dcbe32ad55f1582a0da358ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffe53dcbe32ad55f1582a0da358ac0">&#9670;&nbsp;</a></span>evutil_secure_rng_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_secure_rng_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seed the secure random number generator if needed, and return 0 on success or -1 on failure. </p>
<p>It is okay to call this function more than once; it will still return 0 if the RNG has been successfully seeded and -1 if it can't be seeded.</p>
<p>Ordinarily you don't need to call this function from your own code; Libevent will seed the RNG itself the first time it needs good random numbers. You only need to call it if (a) you want to double-check that one of the seeding methods did succeed, or (b) you plan to drop the capability to seed (by chrooting, or dropping capabilities, or whatever), and you want to make sure that seeding happens before your program loses the ability to do it. </p>

</div>
</div>
<a id="a4544ddceb4e20c8c52985641ca829b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4544ddceb4e20c8c52985641ca829b7e">&#9670;&nbsp;</a></span>evutil_secure_rng_set_urandom_device_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_secure_rng_set_urandom_device_file </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a filename to use in place of /dev/urandom for seeding the secure PRNG. </p>
<p>Return 0 on success, -1 on failure.</p>
<p>Call this function BEFORE calling any other initialization or RNG functions.</p>
<p>(This string will <em>NOT</em> be copied internally. Do not free it while any user of the secure RNG might be running. Don't pass anything other than a real /dev/...random device file here, or you might lose security.)</p>
<p>This API is unstable, and might change in a future libevent version. </p>

</div>
</div>
<a id="a7b5ad1074f1effe2dbfa18b3f44b589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5ad1074f1effe2dbfa18b3f44b589f">&#9670;&nbsp;</a></span>evutil_sockaddr_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_sockaddr_cmp </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>include_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2. </p>
<p>If include_port is true, consider the port as well as the address. Only implemented for AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain the same between Libevent versions. </p>

</div>
</div>
<a id="a0d08d44d7b2823a9c4e218c69160d9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d08d44d7b2823a9c4e218c69160d9ab">&#9670;&nbsp;</a></span>evutil_socketpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_socketpair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sv</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create two new sockets that are connected to each other. </p>
<p>On Unix, this simply calls socketpair(). On Windows, it uses the loopback network interface on 127.0.0.1, and only AF_INET,SOCK_STREAM are supported.</p>
<p>(This may fail on some Windows hosts where firewall software has cleverly decided to keep 127.0.0.1 from talking to itself.)</p>
<p>Parameters and return values are as for socketpair() </p>

</div>
</div>
<a id="a9175e63729c256eb2646e11e8211f4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9175e63729c256eb2646e11e8211f4f7">&#9670;&nbsp;</a></span>evutil_strtoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL ev_int64_t evutil_strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a 64-bit value from a string. </p>
<p>Arguments are as for strtol. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
