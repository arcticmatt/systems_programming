<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libevent: event2/dns.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libevent
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_db160b4728e6067cf5f9cc14ec42c79d.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dns.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br />
</div>
<p><a href="dns_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa213c5179d5439b1ceb6b356cfa6670a"><td class="memItemLeft" align="right" valign="top"><a id="aa213c5179d5439b1ceb6b356cfa6670a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#aa213c5179d5439b1ceb6b356cfa6670a">DNS_ERR_CANCEL</a>&#160;&#160;&#160;69</td></tr>
<tr class="memdesc:aa213c5179d5439b1ceb6b356cfa6670a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request was canceled via a call to evdns_cancel_request. <br /></td></tr>
<tr class="separator:aa213c5179d5439b1ceb6b356cfa6670a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83b8dba06d732f95c5134a26189bf07"><td class="memItemLeft" align="right" valign="top"><a id="af83b8dba06d732f95c5134a26189bf07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#af83b8dba06d732f95c5134a26189bf07">DNS_ERR_FORMAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:af83b8dba06d732f95c5134a26189bf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name server was unable to interpret the query. <br /></td></tr>
<tr class="separator:af83b8dba06d732f95c5134a26189bf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339623396788ff9271b5cc345b83a2e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a339623396788ff9271b5cc345b83a2e8">DNS_ERR_NODATA</a>&#160;&#160;&#160;70</td></tr>
<tr class="memdesc:a339623396788ff9271b5cc345b83a2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">There were no answers and no error condition in the DNS packet.  <a href="dns_8h.html#a339623396788ff9271b5cc345b83a2e8">More...</a><br /></td></tr>
<tr class="separator:a339623396788ff9271b5cc345b83a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab3095d5fc6b9b476753f1dc43ca062"><td class="memItemLeft" align="right" valign="top"><a id="a9ab3095d5fc6b9b476753f1dc43ca062"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a9ab3095d5fc6b9b476753f1dc43ca062">DNS_ERR_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a9ab3095d5fc6b9b476753f1dc43ca062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes 0-5 are as described in RFC 1035. <br /></td></tr>
<tr class="separator:a9ab3095d5fc6b9b476753f1dc43ca062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a1417da1abb3ec925bac4bdc9dda00"><td class="memItemLeft" align="right" valign="top"><a id="a69a1417da1abb3ec925bac4bdc9dda00"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a69a1417da1abb3ec925bac4bdc9dda00">DNS_ERR_NOTEXIST</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a69a1417da1abb3ec925bac4bdc9dda00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain name does not exist. <br /></td></tr>
<tr class="separator:a69a1417da1abb3ec925bac4bdc9dda00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c885f89aab5bba9636bcab0b2bb46f"><td class="memItemLeft" align="right" valign="top"><a id="ad4c885f89aab5bba9636bcab0b2bb46f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ad4c885f89aab5bba9636bcab0b2bb46f">DNS_ERR_NOTIMPL</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ad4c885f89aab5bba9636bcab0b2bb46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name server does not support the requested kind of query. <br /></td></tr>
<tr class="separator:ad4c885f89aab5bba9636bcab0b2bb46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2612a0b4f473b2e0d8353968cf958c8"><td class="memItemLeft" align="right" valign="top"><a id="ac2612a0b4f473b2e0d8353968cf958c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ac2612a0b4f473b2e0d8353968cf958c8">DNS_ERR_REFUSED</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ac2612a0b4f473b2e0d8353968cf958c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name server refuses to reform the specified operation for policy reasons. <br /></td></tr>
<tr class="separator:ac2612a0b4f473b2e0d8353968cf958c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288664d29454d839d3337c9f1a16287b"><td class="memItemLeft" align="right" valign="top"><a id="a288664d29454d839d3337c9f1a16287b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a288664d29454d839d3337c9f1a16287b">DNS_ERR_SERVERFAILED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a288664d29454d839d3337c9f1a16287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name server was unable to process this query due to a problem with the name server. <br /></td></tr>
<tr class="separator:a288664d29454d839d3337c9f1a16287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64cc74ddb454b815d42e23b4d24bf16"><td class="memItemLeft" align="right" valign="top"><a id="ad64cc74ddb454b815d42e23b4d24bf16"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ad64cc74ddb454b815d42e23b4d24bf16">DNS_ERR_SHUTDOWN</a>&#160;&#160;&#160;68</td></tr>
<tr class="memdesc:ad64cc74ddb454b815d42e23b4d24bf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request was canceled because the DNS subsystem was shut down. <br /></td></tr>
<tr class="separator:ad64cc74ddb454b815d42e23b4d24bf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb501430c13d4432314859d36b21c59c"><td class="memItemLeft" align="right" valign="top"><a id="acb501430c13d4432314859d36b21c59c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#acb501430c13d4432314859d36b21c59c">DNS_ERR_TIMEOUT</a>&#160;&#160;&#160;67</td></tr>
<tr class="memdesc:acb501430c13d4432314859d36b21c59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication with the server timed out. <br /></td></tr>
<tr class="separator:acb501430c13d4432314859d36b21c59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab133c94928a9ebe3d37ad5a5d3722fb8"><td class="memItemLeft" align="right" valign="top"><a id="ab133c94928a9ebe3d37ad5a5d3722fb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ab133c94928a9ebe3d37ad5a5d3722fb8">DNS_ERR_TRUNCATED</a>&#160;&#160;&#160;65</td></tr>
<tr class="memdesc:ab133c94928a9ebe3d37ad5a5d3722fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reply was truncated or ill-formatted. <br /></td></tr>
<tr class="separator:ab133c94928a9ebe3d37ad5a5d3722fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9900444d399cb6d516e40a1629f79"><td class="memItemLeft" align="right" valign="top"><a id="a09a9900444d399cb6d516e40a1629f79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a09a9900444d399cb6d516e40a1629f79">DNS_ERR_UNKNOWN</a>&#160;&#160;&#160;66</td></tr>
<tr class="memdesc:a09a9900444d399cb6d516e40a1629f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unknown error occurred. <br /></td></tr>
<tr class="separator:a09a9900444d399cb6d516e40a1629f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bdba92fba6851649178796a61e6e48"><td class="memItemLeft" align="right" valign="top"><a id="a17bdba92fba6851649178796a61e6e48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_IPv4_A</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a17bdba92fba6851649178796a61e6e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8f109c67c35edaf2fa5628a39e8591"><td class="memItemLeft" align="right" valign="top"><a id="acb8f109c67c35edaf2fa5628a39e8591"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_IPv6_AAAA</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:acb8f109c67c35edaf2fa5628a39e8591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347dc763a4e66bed0e1b340f53aa1b6d"><td class="memItemLeft" align="right" valign="top"><a id="a347dc763a4e66bed0e1b340f53aa1b6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_NO_SEARCH</b>&#160;&#160;&#160;DNS_QUERY_NO_SEARCH</td></tr>
<tr class="separator:a347dc763a4e66bed0e1b340f53aa1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1354f68d965a9b454f4f1e710b5decc"><td class="memItemLeft" align="right" valign="top"><a id="ad1354f68d965a9b454f4f1e710b5decc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_OPTION_HOSTSFILE</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ad1354f68d965a9b454f4f1e710b5decc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96b65439eb5d0f839e20eb52ce59612"><td class="memItemLeft" align="right" valign="top"><a id="ae96b65439eb5d0f839e20eb52ce59612"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_OPTION_MISC</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ae96b65439eb5d0f839e20eb52ce59612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4837b11510c062456bbc86f12ccbd932"><td class="memItemLeft" align="right" valign="top"><a id="a4837b11510c062456bbc86f12ccbd932"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_OPTION_NAMESERVERS</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a4837b11510c062456bbc86f12ccbd932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599d1ceda8b32615f8682d5f7abc356"><td class="memItemLeft" align="right" valign="top"><a id="a4599d1ceda8b32615f8682d5f7abc356"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_OPTION_NAMESERVERS_NO_DEFAULT</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a4599d1ceda8b32615f8682d5f7abc356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49145d945a502797f174804ff60fc075"><td class="memItemLeft" align="right" valign="top"><a id="a49145d945a502797f174804ff60fc075"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_OPTION_SEARCH</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a49145d945a502797f174804ff60fc075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417f74bbbbd887a84d911ed9dc7ce3ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a417f74bbbbd887a84d911ed9dc7ce3ae">DNS_OPTIONS_ALL</a></td></tr>
<tr class="memdesc:a417f74bbbbd887a84d911ed9dc7ce3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">All above:  <a href="dns_8h.html#a417f74bbbbd887a84d911ed9dc7ce3ae">More...</a><br /></td></tr>
<tr class="separator:a417f74bbbbd887a84d911ed9dc7ce3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69594a709159a6607376597d6fcfc86"><td class="memItemLeft" align="right" valign="top"><a id="af69594a709159a6607376597d6fcfc86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_PTR</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:af69594a709159a6607376597d6fcfc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82856a398b08ac3a1bb2d540fa9c742"><td class="memItemLeft" align="right" valign="top"><a id="af82856a398b08ac3a1bb2d540fa9c742"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DNS_QUERY_NO_SEARCH</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:af82856a398b08ac3a1bb2d540fa9c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa98a0d41eb8da13399fb9716d2a5b3"><td class="memItemLeft" align="right" valign="top"><a id="afaa98a0d41eb8da13399fb9716d2a5b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_ADDITIONAL_SECTION</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:afaa98a0d41eb8da13399fb9716d2a5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe36ef3f24e398558b7e6b2f5c82df0"><td class="memItemLeft" align="right" valign="top"><a id="abfe36ef3f24e398558b7e6b2f5c82df0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_ANSWER_SECTION</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:abfe36ef3f24e398558b7e6b2f5c82df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5931aa57d8552e0c94f4a8638e6db2ce"><td class="memItemLeft" align="right" valign="top"><a id="a5931aa57d8552e0c94f4a8638e6db2ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_AUTHORITY_SECTION</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5931aa57d8552e0c94f4a8638e6db2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be862f798b16642b5d911e05386a072"><td class="memItemLeft" align="right" valign="top"><a id="a0be862f798b16642b5d911e05386a072"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED</b></td></tr>
<tr class="separator:a0be862f798b16642b5d911e05386a072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676c79dfd2107701961fe2b269dcfd8"><td class="memItemLeft" align="right" valign="top"><a id="ad676c79dfd2107701961fe2b269dcfd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ad676c79dfd2107701961fe2b269dcfd8">EVDNS_BASE_DISABLE_WHEN_INACTIVE</a>&#160;&#160;&#160;0x8000</td></tr>
<tr class="memdesc:ad676c79dfd2107701961fe2b269dcfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for evdns_base_new: Do not prevent the libevent event loop from exiting when we have no active dns requests. <br /></td></tr>
<tr class="separator:ad676c79dfd2107701961fe2b269dcfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbcfe6baf59913c34aa04e57637da3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1cbcfe6baf59913c34aa04e57637da3d">EVDNS_BASE_INITIALIZE_NAMESERVERS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1cbcfe6baf59913c34aa04e57637da3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for evdns_base_new: process resolv.conf.  <a href="dns_8h.html#a1cbcfe6baf59913c34aa04e57637da3d">More...</a><br /></td></tr>
<tr class="separator:a1cbcfe6baf59913c34aa04e57637da3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548a0e3529efb572b991408f7581a09b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a548a0e3529efb572b991408f7581a09b">EVDNS_BASE_NAMESERVERS_NO_DEFAULT</a>&#160;&#160;&#160;0x10000</td></tr>
<tr class="memdesc:a548a0e3529efb572b991408f7581a09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for evdns_base_new: If EVDNS_BASE_INITIALIZE_NAMESERVERS isset, do not add default nameserver if there are no nameservers in resolv.conf.  <a href="dns_8h.html#a548a0e3529efb572b991408f7581a09b">More...</a><br /></td></tr>
<tr class="separator:a548a0e3529efb572b991408f7581a09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cbeaca3ff13f05c94a4308489bbcf6"><td class="memItemLeft" align="right" valign="top"><a id="aa3cbeaca3ff13f05c94a4308489bbcf6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_CLASS_INET</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa3cbeaca3ff13f05c94a4308489bbcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4955faa41f42dd3d5392de0f510b2d5b"><td class="memItemLeft" align="right" valign="top"><a id="a4955faa41f42dd3d5392de0f510b2d5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_FLAGS_AA</b>&#160;&#160;&#160;0x400</td></tr>
<tr class="separator:a4955faa41f42dd3d5392de0f510b2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6512e054966c28adc1d160509a03f54"><td class="memItemLeft" align="right" valign="top"><a id="aa6512e054966c28adc1d160509a03f54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_FLAGS_RD</b>&#160;&#160;&#160;0x080</td></tr>
<tr class="separator:aa6512e054966c28adc1d160509a03f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4910befc342a418494f91c1e68a263b0"><td class="memItemLeft" align="right" valign="top"><a id="a4910befc342a418494f91c1e68a263b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_QTYPE_ALL</b>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a4910befc342a418494f91c1e68a263b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca6e7eb2768c8b190c66c9db70d54d"><td class="memItemLeft" align="right" valign="top"><a id="accca6e7eb2768c8b190c66c9db70d54d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_QTYPE_AXFR</b>&#160;&#160;&#160;252</td></tr>
<tr class="separator:accca6e7eb2768c8b190c66c9db70d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d8b1d5dade064329458e64f66fea0"><td class="memItemLeft" align="right" valign="top"><a id="a4e8d8b1d5dade064329458e64f66fea0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_A</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a4e8d8b1d5dade064329458e64f66fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c31c8794d88ca0415d3a082655098d0"><td class="memItemLeft" align="right" valign="top"><a id="a9c31c8794d88ca0415d3a082655098d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_AAAA</b>&#160;&#160;&#160;28</td></tr>
<tr class="separator:a9c31c8794d88ca0415d3a082655098d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb31989f56eae67bc02c23be47b1383b"><td class="memItemLeft" align="right" valign="top"><a id="abb31989f56eae67bc02c23be47b1383b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_CNAME</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:abb31989f56eae67bc02c23be47b1383b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8abe47a00707401291a9a6c37a5e6b"><td class="memItemLeft" align="right" valign="top"><a id="aea8abe47a00707401291a9a6c37a5e6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_MX</b>&#160;&#160;&#160;15</td></tr>
<tr class="separator:aea8abe47a00707401291a9a6c37a5e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f887413ecc76162da14b6680f9fb46"><td class="memItemLeft" align="right" valign="top"><a id="aa5f887413ecc76162da14b6680f9fb46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_NS</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aa5f887413ecc76162da14b6680f9fb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6343c162297e966a7b4f93f3ef64e433"><td class="memItemLeft" align="right" valign="top"><a id="a6343c162297e966a7b4f93f3ef64e433"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_PTR</b>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a6343c162297e966a7b4f93f3ef64e433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a20816cd4a40625a73217371592497f"><td class="memItemLeft" align="right" valign="top"><a id="a8a20816cd4a40625a73217371592497f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_SOA</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a8a20816cd4a40625a73217371592497f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4fb68c7c44ff643cdd83d95f366f27"><td class="memItemLeft" align="right" valign="top"><a id="abb4fb68c7c44ff643cdd83d95f366f27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVDNS_TYPE_TXT</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:abb4fb68c7c44ff643cdd83d95f366f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a43018959c4be1a9b16e4143c5e3ff556"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a>) (int result, char type, int count, int ttl, void *addresses, void *arg)</td></tr>
<tr class="memdesc:a43018959c4be1a9b16e4143c5e3ff556"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback that contains the results from a lookup.  <a href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">More...</a><br /></td></tr>
<tr class="separator:a43018959c4be1a9b16e4143c5e3ff556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850904a1dbd8c8a087dc2be7617e21c8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a850904a1dbd8c8a087dc2be7617e21c8">evdns_debug_log_fn_type</a>) (int is_warning, const char *msg)</td></tr>
<tr class="memdesc:a850904a1dbd8c8a087dc2be7617e21c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that is invoked when a log message is generated.  <a href="dns_8h.html#a850904a1dbd8c8a087dc2be7617e21c8">More...</a><br /></td></tr>
<tr class="separator:a850904a1dbd8c8a087dc2be7617e21c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1464f191ef7678be0d4caf3644a8f4"><td class="memItemLeft" align="right" valign="top"><a id="a0d1464f191ef7678be0d4caf3644a8f4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a0d1464f191ef7678be0d4caf3644a8f4">evdns_getaddrinfo_cb</a>) (int result, struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *res, void *arg)</td></tr>
<tr class="memdesc:a0d1464f191ef7678be0d4caf3644a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for evdns_getaddrinfo. <br /></td></tr>
<tr class="separator:a0d1464f191ef7678be0d4caf3644a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052802966f4c9d482279a05197dff005"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a052802966f4c9d482279a05197dff005">evdns_request_callback_fn_type</a>) (struct evdns_server_request *, void *)</td></tr>
<tr class="memdesc:a052802966f4c9d482279a05197dff005"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback to implement a DNS server.  <a href="dns_8h.html#a052802966f4c9d482279a05197dff005">More...</a><br /></td></tr>
<tr class="separator:a052802966f4c9d482279a05197dff005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6a51e72173fcb3df380a49e8589635b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_server_port *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ad6a51e72173fcb3df380a49e8589635b">evdns_add_server_port_with_base</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> socket, int flags, <a class="el" href="dns_8h.html#a052802966f4c9d482279a05197dff005">evdns_request_callback_fn_type</a> callback, void *user_data)</td></tr>
<tr class="memdesc:ad6a51e72173fcb3df380a49e8589635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DNS server port.  <a href="dns_8h.html#ad6a51e72173fcb3df380a49e8589635b">More...</a><br /></td></tr>
<tr class="separator:ad6a51e72173fcb3df380a49e8589635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1875001046dd6cbff5f2139590221ddf"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1875001046dd6cbff5f2139590221ddf">evdns_base_clear_host_addresses</a> (struct evdns_base *base)</td></tr>
<tr class="memdesc:a1875001046dd6cbff5f2139590221ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all hosts entries that have been loaded into the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> via evdns_base_load_hosts or via event_base_resolv_conf_parse.  <a href="dns_8h.html#a1875001046dd6cbff5f2139590221ddf">More...</a><br /></td></tr>
<tr class="separator:a1875001046dd6cbff5f2139590221ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942ce8b6a65052f4b6def91a3390a61"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#af942ce8b6a65052f4b6def91a3390a61">evdns_base_clear_nameservers_and_suspend</a> (struct evdns_base *base)</td></tr>
<tr class="memdesc:af942ce8b6a65052f4b6def91a3390a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all configured nameservers, and suspend all pending resolves.  <a href="dns_8h.html#af942ce8b6a65052f4b6def91a3390a61">More...</a><br /></td></tr>
<tr class="separator:af942ce8b6a65052f4b6def91a3390a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac287c8b638a248719a00b0324579b728"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ac287c8b638a248719a00b0324579b728">evdns_base_config_windows_nameservers</a> (struct evdns_base *)</td></tr>
<tr class="memdesc:ac287c8b638a248719a00b0324579b728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain nameserver information using the Windows API.  <a href="dns_8h.html#ac287c8b638a248719a00b0324579b728">More...</a><br /></td></tr>
<tr class="separator:ac287c8b638a248719a00b0324579b728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6811354521b4fe8df4c724d6cb9fb102"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a6811354521b4fe8df4c724d6cb9fb102">evdns_base_count_nameservers</a> (struct evdns_base *base)</td></tr>
<tr class="memdesc:a6811354521b4fe8df4c724d6cb9fb102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of configured nameservers.  <a href="dns_8h.html#a6811354521b4fe8df4c724d6cb9fb102">More...</a><br /></td></tr>
<tr class="separator:a6811354521b4fe8df4c724d6cb9fb102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab221bbadb18451c9007e8dc98bc97786"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ab221bbadb18451c9007e8dc98bc97786">evdns_base_free</a> (struct evdns_base *base, int fail_requests)</td></tr>
<tr class="memdesc:ab221bbadb18451c9007e8dc98bc97786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the asynchronous DNS resolver and terminate all active requests.  <a href="dns_8h.html#ab221bbadb18451c9007e8dc98bc97786">More...</a><br /></td></tr>
<tr class="separator:ab221bbadb18451c9007e8dc98bc97786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1545f7930f228018a06476a7236bfe0e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1545f7930f228018a06476a7236bfe0e">evdns_base_get_nameserver_addr</a> (struct evdns_base *base, int idx, struct sockaddr *sa, ev_socklen_t len)</td></tr>
<tr class="memdesc:a1545f7930f228018a06476a7236bfe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the address of the 'idx'th configured nameserver.  <a href="dns_8h.html#a1545f7930f228018a06476a7236bfe0e">More...</a><br /></td></tr>
<tr class="separator:a1545f7930f228018a06476a7236bfe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5092d38082851904e37d6b80c3475714"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a5092d38082851904e37d6b80c3475714">evdns_base_load_hosts</a> (struct evdns_base *base, const char *hosts_fname)</td></tr>
<tr class="memdesc:a5092d38082851904e37d6b80c3475714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an /etc/hosts-style file from 'hosts_fname' into 'base'.  <a href="dns_8h.html#a5092d38082851904e37d6b80c3475714">More...</a><br /></td></tr>
<tr class="separator:a5092d38082851904e37d6b80c3475714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a242ec2ab15eef9e49e4286153d55a"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a53a242ec2ab15eef9e49e4286153d55a">evdns_base_nameserver_add</a> (struct evdns_base *base, unsigned long int address)</td></tr>
<tr class="memdesc:a53a242ec2ab15eef9e49e4286153d55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a nameserver.  <a href="dns_8h.html#a53a242ec2ab15eef9e49e4286153d55a">More...</a><br /></td></tr>
<tr class="separator:a53a242ec2ab15eef9e49e4286153d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5f8e71a80a41d10e386f8cac816238"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a0a5f8e71a80a41d10e386f8cac816238">evdns_base_nameserver_ip_add</a> (struct evdns_base *base, const char *ip_as_string)</td></tr>
<tr class="memdesc:a0a5f8e71a80a41d10e386f8cac816238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a nameserver by string address.  <a href="dns_8h.html#a0a5f8e71a80a41d10e386f8cac816238">More...</a><br /></td></tr>
<tr class="separator:a0a5f8e71a80a41d10e386f8cac816238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8feac209d81aea2654809727ee7ada7"><td class="memItemLeft" align="right" valign="top"><a id="ac8feac209d81aea2654809727ee7ada7"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ac8feac209d81aea2654809727ee7ada7">evdns_base_nameserver_sockaddr_add</a> (struct evdns_base *base, const struct sockaddr *sa, ev_socklen_t len, unsigned flags)</td></tr>
<tr class="memdesc:ac8feac209d81aea2654809727ee7ada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a nameserver by sockaddr. <br /></td></tr>
<tr class="separator:ac8feac209d81aea2654809727ee7ada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6d4a705210aa58a4ad6bf810a4410e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_base *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a4d6d4a705210aa58a4ad6bf810a4410e">evdns_base_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *<a class="el" href="structevent__base.html">event_base</a>, int initialize_nameservers)</td></tr>
<tr class="memdesc:a4d6d4a705210aa58a4ad6bf810a4410e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the asynchronous DNS library.  <a href="dns_8h.html#a4d6d4a705210aa58a4ad6bf810a4410e">More...</a><br /></td></tr>
<tr class="separator:a4d6d4a705210aa58a4ad6bf810a4410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3a053e25ae7c045944a5db0947babb"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a7e3a053e25ae7c045944a5db0947babb">evdns_base_resolv_conf_parse</a> (struct evdns_base *base, int flags, const char *const filename)</td></tr>
<tr class="memdesc:a7e3a053e25ae7c045944a5db0947babb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a resolv.conf file.  <a href="dns_8h.html#a7e3a053e25ae7c045944a5db0947babb">More...</a><br /></td></tr>
<tr class="separator:a7e3a053e25ae7c045944a5db0947babb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b11705fa285dffa661c7f55f86693"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a4f8b11705fa285dffa661c7f55f86693">evdns_base_resolve_ipv4</a> (struct evdns_base *base, const char *name, int flags, <a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a> callback, void *ptr)</td></tr>
<tr class="memdesc:a4f8b11705fa285dffa661c7f55f86693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an A record for a given name.  <a href="dns_8h.html#a4f8b11705fa285dffa661c7f55f86693">More...</a><br /></td></tr>
<tr class="separator:a4f8b11705fa285dffa661c7f55f86693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646ca1414b09b9fec7763bf8aca05e74"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a646ca1414b09b9fec7763bf8aca05e74">evdns_base_resolve_ipv6</a> (struct evdns_base *base, const char *name, int flags, <a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a> callback, void *ptr)</td></tr>
<tr class="memdesc:a646ca1414b09b9fec7763bf8aca05e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an AAAA record for a given name.  <a href="dns_8h.html#a646ca1414b09b9fec7763bf8aca05e74">More...</a><br /></td></tr>
<tr class="separator:a646ca1414b09b9fec7763bf8aca05e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9cbcd4c017180e7d302056b3d5bbd4"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1f9cbcd4c017180e7d302056b3d5bbd4">evdns_base_resolve_reverse</a> (struct evdns_base *base, const struct in_addr *in, int flags, <a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a> callback, void *ptr)</td></tr>
<tr class="memdesc:a1f9cbcd4c017180e7d302056b3d5bbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a PTR record for a given IP address.  <a href="dns_8h.html#a1f9cbcd4c017180e7d302056b3d5bbd4">More...</a><br /></td></tr>
<tr class="separator:a1f9cbcd4c017180e7d302056b3d5bbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55843d1e90512bfbe8499d52642240cd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a55843d1e90512bfbe8499d52642240cd">evdns_base_resolve_reverse_ipv6</a> (struct evdns_base *base, const struct in6_addr *in, int flags, <a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a> callback, void *ptr)</td></tr>
<tr class="memdesc:a55843d1e90512bfbe8499d52642240cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a PTR record for a given IPv6 address.  <a href="dns_8h.html#a55843d1e90512bfbe8499d52642240cd">More...</a><br /></td></tr>
<tr class="separator:a55843d1e90512bfbe8499d52642240cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef3a20dd645e02d6dd5d3766ced9ce7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a3ef3a20dd645e02d6dd5d3766ced9ce7">evdns_base_resume</a> (struct evdns_base *base)</td></tr>
<tr class="memdesc:a3ef3a20dd645e02d6dd5d3766ced9ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume normal operation and continue any suspended resolve requests.  <a href="dns_8h.html#a3ef3a20dd645e02d6dd5d3766ced9ce7">More...</a><br /></td></tr>
<tr class="separator:a3ef3a20dd645e02d6dd5d3766ced9ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8044de93700190d5ca6a6a0becdc4f6e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a8044de93700190d5ca6a6a0becdc4f6e">evdns_base_search_add</a> (struct evdns_base *base, const char *domain)</td></tr>
<tr class="memdesc:a8044de93700190d5ca6a6a0becdc4f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain to the list of search domains.  <a href="dns_8h.html#a8044de93700190d5ca6a6a0becdc4f6e">More...</a><br /></td></tr>
<tr class="separator:a8044de93700190d5ca6a6a0becdc4f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211bdca966e8f4ce3270b29c1d72122"><td class="memItemLeft" align="right" valign="top"><a id="a9211bdca966e8f4ce3270b29c1d72122"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a9211bdca966e8f4ce3270b29c1d72122">evdns_base_search_clear</a> (struct evdns_base *base)</td></tr>
<tr class="memdesc:a9211bdca966e8f4ce3270b29c1d72122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of search domains. <br /></td></tr>
<tr class="separator:a9211bdca966e8f4ce3270b29c1d72122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae858583b1c9fdd1f7c99330bcdd68ba6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#ae858583b1c9fdd1f7c99330bcdd68ba6">evdns_base_search_ndots_set</a> (struct evdns_base *base, const int ndots)</td></tr>
<tr class="memdesc:ae858583b1c9fdd1f7c99330bcdd68ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'ndots' parameter for searches.  <a href="dns_8h.html#ae858583b1c9fdd1f7c99330bcdd68ba6">More...</a><br /></td></tr>
<tr class="separator:ae858583b1c9fdd1f7c99330bcdd68ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b6fdc9f41bd62414574d85ae18cc8"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a791b6fdc9f41bd62414574d85ae18cc8">evdns_base_set_option</a> (struct evdns_base *base, const char *option, const char *val)</td></tr>
<tr class="memdesc:a791b6fdc9f41bd62414574d85ae18cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a configuration option.  <a href="dns_8h.html#a791b6fdc9f41bd62414574d85ae18cc8">More...</a><br /></td></tr>
<tr class="separator:a791b6fdc9f41bd62414574d85ae18cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062bdd01f7243b3c8509d93c45a802ef"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef">evdns_cancel_request</a> (struct evdns_base *base, struct evdns_request *req)</td></tr>
<tr class="memdesc:a062bdd01f7243b3c8509d93c45a802ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a pending DNS resolution request.  <a href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef">More...</a><br /></td></tr>
<tr class="separator:a062bdd01f7243b3c8509d93c45a802ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd56ab78c400f46498515330343c66a"><td class="memItemLeft" align="right" valign="top"><a id="abbd56ab78c400f46498515330343c66a"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#abbd56ab78c400f46498515330343c66a">evdns_close_server_port</a> (struct evdns_server_port *port)</td></tr>
<tr class="memdesc:abbd56ab78c400f46498515330343c66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close down a DNS server port, and free associated structures. <br /></td></tr>
<tr class="separator:abbd56ab78c400f46498515330343c66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bb4cf48915f73e4e9c6d4b6216466b"><td class="memItemLeft" align="right" valign="top">const EVENT2_EXPORT_SYMBOL char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a24bb4cf48915f73e4e9c6d4b6216466b">evdns_err_to_string</a> (int err)</td></tr>
<tr class="memdesc:a24bb4cf48915f73e4e9c6d4b6216466b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DNS error code to a string.  <a href="dns_8h.html#a24bb4cf48915f73e4e9c6d4b6216466b">More...</a><br /></td></tr>
<tr class="separator:a24bb4cf48915f73e4e9c6d4b6216466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a4c5e6e22bcf92f8c229461023f914"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evdns_getaddrinfo_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a28a4c5e6e22bcf92f8c229461023f914">evdns_getaddrinfo</a> (struct evdns_base *dns_base, const char *nodename, const char *servname, const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *hints_in, <a class="el" href="dns_8h.html#a0d1464f191ef7678be0d4caf3644a8f4">evdns_getaddrinfo_cb</a> cb, void *arg)</td></tr>
<tr class="memdesc:a28a4c5e6e22bcf92f8c229461023f914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a non-blocking getaddrinfo request using the dns_base in 'dns_base'.  <a href="dns_8h.html#a28a4c5e6e22bcf92f8c229461023f914">More...</a><br /></td></tr>
<tr class="separator:a28a4c5e6e22bcf92f8c229461023f914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a30ea7d80d7f9e02bfaf534560bc30"><td class="memItemLeft" align="right" valign="top"><a id="a80a30ea7d80d7f9e02bfaf534560bc30"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_getaddrinfo_cancel</b> (struct evdns_getaddrinfo_request *req)</td></tr>
<tr class="separator:a80a30ea7d80d7f9e02bfaf534560bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9c5685cd3ffd146734f05d2350b8ba"><td class="memItemLeft" align="right" valign="top"><a id="adb9c5685cd3ffd146734f05d2350b8ba"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_server_request_add_a_reply</b> (struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)</td></tr>
<tr class="separator:adb9c5685cd3ffd146734f05d2350b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff43d2e0a60d3dd2b35c9740954285d2"><td class="memItemLeft" align="right" valign="top"><a id="aff43d2e0a60d3dd2b35c9740954285d2"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_server_request_add_aaaa_reply</b> (struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)</td></tr>
<tr class="separator:aff43d2e0a60d3dd2b35c9740954285d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24109b95a904944693bad032607475f"><td class="memItemLeft" align="right" valign="top"><a id="aa24109b95a904944693bad032607475f"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_server_request_add_cname_reply</b> (struct evdns_server_request *req, const char *name, const char *cname, int ttl)</td></tr>
<tr class="separator:aa24109b95a904944693bad032607475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45308ef807d89c6591e198bbdb5087be"><td class="memItemLeft" align="right" valign="top"><a id="a45308ef807d89c6591e198bbdb5087be"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_server_request_add_ptr_reply</b> (struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)</td></tr>
<tr class="separator:a45308ef807d89c6591e198bbdb5087be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05883ad8db1350f14af3f9285c3962fa"><td class="memItemLeft" align="right" valign="top"><a id="a05883ad8db1350f14af3f9285c3962fa"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>evdns_server_request_add_reply</b> (struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data)</td></tr>
<tr class="separator:a05883ad8db1350f14af3f9285c3962fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291ec11bf79809c4ae1b113bb0160e9"><td class="memItemLeft" align="right" valign="top"><a id="a1291ec11bf79809c4ae1b113bb0160e9"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1291ec11bf79809c4ae1b113bb0160e9">evdns_server_request_drop</a> (struct evdns_server_request *req)</td></tr>
<tr class="memdesc:a1291ec11bf79809c4ae1b113bb0160e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a DNS request without sending back a reply. <br /></td></tr>
<tr class="separator:a1291ec11bf79809c4ae1b113bb0160e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ce45f71d886514ece8688e19ead19"><td class="memItemLeft" align="right" valign="top"><a id="a078ce45f71d886514ece8688e19ead19"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a078ce45f71d886514ece8688e19ead19">evdns_server_request_get_requesting_addr</a> (struct evdns_server_request *req, struct sockaddr *sa, int addr_len)</td></tr>
<tr class="memdesc:a078ce45f71d886514ece8688e19ead19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address that made a DNS request. <br /></td></tr>
<tr class="separator:a078ce45f71d886514ece8688e19ead19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b067e5cd3fee40b527b3cb4ec2d72"><td class="memItemLeft" align="right" valign="top"><a id="a606b067e5cd3fee40b527b3cb4ec2d72"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a606b067e5cd3fee40b527b3cb4ec2d72">evdns_server_request_respond</a> (struct evdns_server_request *req, int err)</td></tr>
<tr class="memdesc:a606b067e5cd3fee40b527b3cb4ec2d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send back a response to a DNS request, and free the request structure. <br /></td></tr>
<tr class="separator:a606b067e5cd3fee40b527b3cb4ec2d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849622fc8fee97302a6a0a34e7e6feb8"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a849622fc8fee97302a6a0a34e7e6feb8">evdns_server_request_set_flags</a> (struct evdns_server_request *req, int flags)</td></tr>
<tr class="memdesc:a849622fc8fee97302a6a0a34e7e6feb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets some flags in a reply we're building.  <a href="dns_8h.html#a849622fc8fee97302a6a0a34e7e6feb8">More...</a><br /></td></tr>
<tr class="separator:a849622fc8fee97302a6a0a34e7e6feb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ba90756cecdc246711879462a20b51"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#af2ba90756cecdc246711879462a20b51">evdns_set_log_fn</a> (<a class="el" href="dns_8h.html#a850904a1dbd8c8a087dc2be7617e21c8">evdns_debug_log_fn_type</a> fn)</td></tr>
<tr class="memdesc:af2ba90756cecdc246711879462a20b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function to handle DNS log messages.  <a href="dns_8h.html#af2ba90756cecdc246711879462a20b51">More...</a><br /></td></tr>
<tr class="separator:af2ba90756cecdc246711879462a20b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cdd8e2c2fbdc2ba9685f11c2d229ee"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a87cdd8e2c2fbdc2ba9685f11c2d229ee">evdns_set_random_bytes_fn</a> (void(*fn)(char *, size_t))</td></tr>
<tr class="memdesc:a87cdd8e2c2fbdc2ba9685f11c2d229ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback used to generate random bytes.  <a href="dns_8h.html#a87cdd8e2c2fbdc2ba9685f11c2d229ee">More...</a><br /></td></tr>
<tr class="separator:a87cdd8e2c2fbdc2ba9685f11c2d229ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c9dded0901a52eb2b92ed5a98e9bd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dns_8h.html#a1e4c9dded0901a52eb2b92ed5a98e9bd">evdns_set_transaction_id_fn</a> (ev_uint16_t(*fn)(void))</td></tr>
<tr class="memdesc:a1e4c9dded0901a52eb2b92ed5a98e9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback that will be invoked to generate transaction IDs.  <a href="dns_8h.html#a1e4c9dded0901a52eb2b92ed5a98e9bd">More...</a><br /></td></tr>
<tr class="separator:a1e4c9dded0901a52eb2b92ed5a98e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Welcome, gentle reader</p>
<p>Async DNS lookups are really a whole lot harder than they should be, mostly stemming from the fact that the libc resolver has never been very good at them. Before you use this library you should see if libc can do the job for you with the modern async call getaddrinfo_a (see <a href="http://www.imperialviolet.org/page25.html#e498">http://www.imperialviolet.org/page25.html#e498</a>). Otherwise, please continue.</p>
<p>The library keeps track of the state of nameservers and will avoid them when they go down. Otherwise it will round robin between them.</p>
<p>Quick start guide: #include "evdns.h" void callback(int result, char type, int count, int ttl, void *addresses, void *arg); evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf"); evdns_resolve("www.hostname.com", 0, callback, NULL);</p>
<p>When the lookup is complete the callback function is called. The first argument will be one of the DNS_ERR_* defines in evdns.h. Hopefully it will be DNS_ERR_NONE, in which case type will be DNS_IPv4_A, count will be the number of IP addresses, ttl is the time which the data can be cached for (in seconds), addresses will point to an array of uint32_t's and arg will be whatever you passed to evdns_resolve.</p>
<p>Searching:</p>
<p>In order for this library to be a good replacement for glibc's resolver it supports searching. This involves setting a list of default domains, in which names will be queried for. The number of dots in the query name determines the order in which this list is used.</p>
<p>Searching appears to be a single lookup from the point of view of the API, although many DNS queries may be generated from a single call to evdns_resolve. Searching can also drastically slow down the resolution of names.</p>
<p>To disable searching:</p><ol type="1">
<li>Never set it up. If you never call evdns_resolv_conf_parse or evdns_search_add then no searching will occur.</li>
<li>If you do call evdns_resolv_conf_parse then don't pass DNS_OPTION_SEARCH (or DNS_OPTIONS_ALL, which implies it).</li>
<li>When calling evdns_resolve, pass the DNS_QUERY_NO_SEARCH flag.</li>
</ol>
<p>The order of searches depends on the number of dots in the name. If the number is greater than the ndots setting then the names is first tried globally. Otherwise each search domain is appended in turn.</p>
<p>The ndots setting can either be set from a resolv.conf, or by calling evdns_search_ndots_set.</p>
<p>For example, with ndots set to 1 (the default) and a search domain list of ["myhome.net"]: Query: www Order: www.myhome.net, www.</p>
<p>Query: www.abc Order: www.abc., www.abc.myhome.net</p>
<p>Internals:</p>
<p>Requests are kept in two queues. The first is the inflight queue. In this queue requests have an allocated transaction id and nameserver. They will soon be transmitted if they haven't already been.</p>
<p>The second is the waiting queue. The size of the inflight ring is limited and all other requests wait in waiting queue for space. This bounds the number of concurrent requests so that we don't flood the nameserver. Several algorithms require a full walk of the inflight queue and so bounding its size keeps thing going nicely under huge (many thousands of requests) loads.</p>
<p>If a nameserver loses too many requests it is considered down and we try not to use it. After a while we send a probe to that nameserver (a lookup for google.com) and, if it replies, we consider it working again. If the nameserver fails a probe we wait longer to try again with the next probe. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a339623396788ff9271b5cc345b83a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339623396788ff9271b5cc345b83a2e8">&#9670;&nbsp;</a></span>DNS_ERR_NODATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_ERR_NODATA&#160;&#160;&#160;70</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>There were no answers and no error condition in the DNS packet. </p>
<p>This can happen when you ask for an address that exists, but a record type that doesn't. </p>

</div>
</div>
<a id="a417f74bbbbd887a84d911ed9dc7ce3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417f74bbbbd887a84d911ed9dc7ce3ae">&#9670;&nbsp;</a></span>DNS_OPTIONS_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_OPTIONS_ALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(    \</div>
<div class="line">    DNS_OPTION_SEARCH      | \</div>
<div class="line">    DNS_OPTION_NAMESERVERS | \</div>
<div class="line">    DNS_OPTION_MISC        | \</div>
<div class="line">    DNS_OPTION_HOSTSFILE   | \</div>
<div class="line">    0                        \</div>
<div class="line">)</div>
</div><!-- fragment -->
<p>All above: </p>
<ul>
<li>DNS_OPTION_SEARCH</li>
<li>DNS_OPTION_NAMESERVERS</li>
<li>DNS_OPTION_MISC</li>
<li>DNS_OPTION_HOSTSFILE </li>
</ul>

</div>
</div>
<a id="a1cbcfe6baf59913c34aa04e57637da3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbcfe6baf59913c34aa04e57637da3d">&#9670;&nbsp;</a></span>EVDNS_BASE_INITIALIZE_NAMESERVERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVDNS_BASE_INITIALIZE_NAMESERVERS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for evdns_base_new: process resolv.conf. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a548a0e3529efb572b991408f7581a09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548a0e3529efb572b991408f7581a09b">&#9670;&nbsp;</a></span>EVDNS_BASE_NAMESERVERS_NO_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT&#160;&#160;&#160;0x10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for evdns_base_new: If EVDNS_BASE_INITIALIZE_NAMESERVERS isset, do not add default nameserver if there are no nameservers in resolv.conf. </p>
<dl class="section see"><dt>See also</dt><dd>DNS_OPTION_NAMESERVERS_NO_DEFAULT </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a43018959c4be1a9b16e4143c5e3ff556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43018959c4be1a9b16e4143c5e3ff556">&#9670;&nbsp;</a></span>evdns_callback_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback that contains the results from a lookup. </p>
<ul>
<li>result is one of the DNS_ERR_* values (DNS_ERR_NONE for success)</li>
<li>type is either DNS_IPv4_A or DNS_PTR or DNS_IPv6_AAAA</li>
<li>count contains the number of addresses of form type</li>
<li>ttl is the number of seconds the resolution may be cached for.</li>
<li>addresses needs to be cast according to type. It will be an array of 4-byte sequences for ipv4, or an array of 16-byte sequences for ipv6, or a nul-terminated string for PTR. </li>
</ul>

</div>
</div>
<a id="a850904a1dbd8c8a087dc2be7617e21c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850904a1dbd8c8a087dc2be7617e21c8">&#9670;&nbsp;</a></span>evdns_debug_log_fn_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evdns_debug_log_fn_type) (int is_warning, const char *msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback that is invoked when a log message is generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_warning</td><td>indicates if the log message is a 'warning' </td></tr>
    <tr><td class="paramname">msg</td><td>the content of the log message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a052802966f4c9d482279a05197dff005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052802966f4c9d482279a05197dff005">&#9670;&nbsp;</a></span>evdns_request_callback_fn_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evdns_request_callback_fn_type) (struct evdns_server_request *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback to implement a DNS server. </p>
<p>The callback function receives a DNS request. It should then optionally add a number of answers to the reply using the evdns_server_request_add_*_reply functions, before calling either evdns_server_request_respond to send the reply back, or evdns_server_request_drop to decline to answer the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>A newly received request </td></tr>
    <tr><td class="paramname">user_data</td><td>A pointer that was passed to <a class="el" href="dns_8h.html#ad6a51e72173fcb3df380a49e8589635b" title="Create a new DNS server port.">evdns_add_server_port_with_base()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad6a51e72173fcb3df380a49e8589635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a51e72173fcb3df380a49e8589635b">&#9670;&nbsp;</a></span>evdns_add_server_port_with_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_server_port* evdns_add_server_port_with_base </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a052802966f4c9d482279a05197dff005">evdns_request_callback_fn_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new DNS server port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The event base to handle events for the server port. </td></tr>
    <tr><td class="paramname">socket</td><td>A UDP socket to accept DNS requests. </td></tr>
    <tr><td class="paramname">flags</td><td>Always 0 for now. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to invoke whenever we get a DNS request on the socket. </td></tr>
    <tr><td class="paramname">user_data</td><td>Data to pass to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an evdns_server_port structure for this server port or NULL if an error occurred. </dd></dl>

</div>
</div>
<a id="a1875001046dd6cbff5f2139590221ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1875001046dd6cbff5f2139590221ddf">&#9670;&nbsp;</a></span>evdns_base_clear_host_addresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_base_clear_host_addresses </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all hosts entries that have been loaded into the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> via evdns_base_load_hosts or via event_base_resolv_conf_parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evdns_base</td><td>the evdns base to remove outdated host addresses from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af942ce8b6a65052f4b6def91a3390a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af942ce8b6a65052f4b6def91a3390a61">&#9670;&nbsp;</a></span>evdns_base_clear_nameservers_and_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_clear_nameservers_and_suspend </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all configured nameservers, and suspend all pending resolves. </p>
<p>Resolves will not necessarily be re-attempted until <a class="el" href="dns_8h.html#a3ef3a20dd645e02d6dd5d3766ced9ce7" title="Resume normal operation and continue any suspended resolve requests.">evdns_base_resume()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a3ef3a20dd645e02d6dd5d3766ced9ce7" title="Resume normal operation and continue any suspended resolve requests.">evdns_base_resume()</a> </dd></dl>

</div>
</div>
<a id="ac287c8b638a248719a00b0324579b728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac287c8b638a248719a00b0324579b728">&#9670;&nbsp;</a></span>evdns_base_config_windows_nameservers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_config_windows_nameservers </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain nameserver information using the Windows API. </p>
<p>Attempt to configure a set of nameservers based on platform settings on a win32 host. Preferentially tries to use GetNetworkParams; if that fails, looks in the registry.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns__compat_8h.html#a4dd30bf34468410eb96757007523eb34" title="Parse a resolv.conf file.">evdns_resolv_conf_parse()</a> </dd></dl>

</div>
</div>
<a id="a6811354521b4fe8df4c724d6cb9fb102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6811354521b4fe8df4c724d6cb9fb102">&#9670;&nbsp;</a></span>evdns_base_count_nameservers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_count_nameservers </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of configured nameservers. </p>
<p>This returns the number of configured nameservers (not necessarily the number of running nameservers). This is useful for double-checking whether our calls to the various nameserver configuration functions have been successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of configured nameservers </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a53a242ec2ab15eef9e49e4286153d55a" title="Add a nameserver.">evdns_base_nameserver_add()</a> </dd></dl>

</div>
</div>
<a id="ab221bbadb18451c9007e8dc98bc97786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab221bbadb18451c9007e8dc98bc97786">&#9670;&nbsp;</a></span>evdns_base_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_base_free </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fail_requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down the asynchronous DNS resolver and terminate all active requests. </p>
<p>If the 'fail_requests' option is enabled, all active requests will return an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise, the requests will be silently discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evdns_base</td><td>the evdns base to free </td></tr>
    <tr><td class="paramname">fail_requests</td><td>if zero, active requests will be aborted; if non-zero, active requests will return DNS_ERR_SHUTDOWN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a4d6d4a705210aa58a4ad6bf810a4410e" title="Initialize the asynchronous DNS library.">evdns_base_new()</a> </dd></dl>

</div>
</div>
<a id="a1545f7930f228018a06476a7236bfe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1545f7930f228018a06476a7236bfe0e">&#9670;&nbsp;</a></span>evdns_base_get_nameserver_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_get_nameserver_addr </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_socklen_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the address of the 'idx'th configured nameserver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The evdns_base to examine. </td></tr>
    <tr><td class="paramname">idx</td><td>The index of the nameserver to get the address of. </td></tr>
    <tr><td class="paramname">sa</td><td>A location to receive the server's address. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes available at sa.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written into sa on success. On failure, returns -1 if idx is greater than the number of configured nameservers, or a value greater than 'len' if len was not high enough. </dd></dl>

</div>
</div>
<a id="a5092d38082851904e37d6b80c3475714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5092d38082851904e37d6b80c3475714">&#9670;&nbsp;</a></span>evdns_base_load_hosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_load_hosts </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hosts_fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an /etc/hosts-style file from 'hosts_fname' into 'base'. </p>
<p>If hosts_fname is NULL, add minimal entries for localhost, and nothing else.</p>
<p>Note that only evdns_getaddrinfo uses the /etc/hosts entries.</p>
<p>This function does not replace previously loaded hosts entries; to do that, call evdns_base_clear_host_addresses first.</p>
<p>Return 0 on success, negative on failure. </p>

</div>
</div>
<a id="a53a242ec2ab15eef9e49e4286153d55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a242ec2ab15eef9e49e4286153d55a">&#9670;&nbsp;</a></span>evdns_base_nameserver_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_nameserver_add </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a nameserver. </p>
<p>The address should be an IPv4 address in network byte order. The type of address is chosen so that it matches in_addr.s_addr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to add the name server </td></tr>
    <tr><td class="paramname">address</td><td>an IP address in network byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a0a5f8e71a80a41d10e386f8cac816238" title="Add a nameserver by string address.">evdns_base_nameserver_ip_add()</a> </dd></dl>

</div>
</div>
<a id="a0a5f8e71a80a41d10e386f8cac816238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5f8e71a80a41d10e386f8cac816238">&#9670;&nbsp;</a></span>evdns_base_nameserver_ip_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_nameserver_ip_add </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip_as_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a nameserver by string address. </p>
<p>This function parses a n IPv4 or IPv6 address from a string and adds it as a nameserver. It supports the following formats:</p><ul>
<li>[IPv6Address]:port</li>
<li>[IPv6Address]</li>
<li>IPv6Address</li>
<li>IPv4Address:port</li>
<li>IPv4Address</li>
</ul>
<p>If no port is specified, it defaults to 53.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a53a242ec2ab15eef9e49e4286153d55a" title="Add a nameserver.">evdns_base_nameserver_add()</a> </dd></dl>

</div>
</div>
<a id="a4d6d4a705210aa58a4ad6bf810a4410e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6d4a705210aa58a4ad6bf810a4410e">&#9670;&nbsp;</a></span>evdns_base_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_base* evdns_base_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialize_nameservers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the asynchronous DNS library. </p>
<p>This function initializes support for non-blocking name resolution by calling <a class="el" href="dns__compat_8h.html#a4dd30bf34468410eb96757007523eb34" title="Parse a resolv.conf file.">evdns_resolv_conf_parse()</a> on UNIX and evdns_config_windows_nameservers() on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a></td><td>the event base to associate the dns client with </td></tr>
    <tr><td class="paramname">flags</td><td>any of EVDNS_BASE_INITIALIZE_NAMESERVERS| EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evdns_base object if successful, or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#ab221bbadb18451c9007e8dc98bc97786" title="Shut down the asynchronous DNS resolver and terminate all active requests.">evdns_base_free()</a> </dd></dl>

</div>
</div>
<a id="a7e3a053e25ae7c045944a5db0947babb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3a053e25ae7c045944a5db0947babb">&#9670;&nbsp;</a></span>evdns_base_resolv_conf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_resolv_conf_parse </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a resolv.conf file. </p>
<p>The 'flags' parameter determines what information is parsed from the resolv.conf file. See the man page for resolv.conf for the format of this file.</p>
<p>The following directives are not parsed from the file: sortlist, rotate, no-check-names, inet6, debug.</p>
<p>If this function encounters an error, the possible return values are: 1 = failed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of memory, 5 = short read from file, 6 = no nameservers listed in the file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">flags</td><td>any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC| DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT </td></tr>
    <tr><td class="paramname">filename</td><td>the path to the resolv.conf file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or various positive error codes if an error occurred (see above) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resolv.conf(3), evdns_config_windows_nameservers() </dd></dl>

</div>
</div>
<a id="a4f8b11705fa285dffa661c7f55f86693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b11705fa285dffa661c7f55f86693">&#9670;&nbsp;</a></span>evdns_base_resolve_ipv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_request* evdns_base_resolve_ipv4 </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup an A record for a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">name</td><td>a DNS hostname </td></tr>
    <tr><td class="paramname">flags</td><td>either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query. </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to invoke when the request is completed </td></tr>
    <tr><td class="paramname">ptr</td><td>an argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an evdns_request object if successful, or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns__compat_8h.html#a295f72a34e9744a7026261c078c03f13" title="Lookup an AAAA record for a given name.">evdns_resolve_ipv6()</a>, <a class="el" href="dns__compat_8h.html#a30c78f62647609846c2bb3222ebce87e" title="Lookup a PTR record for a given IP address.">evdns_resolve_reverse()</a>, <a class="el" href="dns__compat_8h.html#a45bf87a8a77c7fba752836aab6a5a9cb" title="Lookup a PTR record for a given IPv6 address.">evdns_resolve_reverse_ipv6()</a>, <a class="el" href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef" title="Cancels a pending DNS resolution request.">evdns_cancel_request()</a> </dd></dl>

</div>
</div>
<a id="a646ca1414b09b9fec7763bf8aca05e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646ca1414b09b9fec7763bf8aca05e74">&#9670;&nbsp;</a></span>evdns_base_resolve_ipv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_request* evdns_base_resolve_ipv6 </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup an AAAA record for a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">name</td><td>a DNS hostname </td></tr>
    <tr><td class="paramname">flags</td><td>either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query. </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to invoke when the request is completed </td></tr>
    <tr><td class="paramname">ptr</td><td>an argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an evdns_request object if successful, or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns__compat_8h.html#a438a9e699ff81b4a22cc072ad3c8e1c2" title="Lookup an A record for a given name.">evdns_resolve_ipv4()</a>, <a class="el" href="dns__compat_8h.html#a30c78f62647609846c2bb3222ebce87e" title="Lookup a PTR record for a given IP address.">evdns_resolve_reverse()</a>, <a class="el" href="dns__compat_8h.html#a45bf87a8a77c7fba752836aab6a5a9cb" title="Lookup a PTR record for a given IPv6 address.">evdns_resolve_reverse_ipv6()</a>, <a class="el" href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef" title="Cancels a pending DNS resolution request.">evdns_cancel_request()</a> </dd></dl>

</div>
</div>
<a id="a1f9cbcd4c017180e7d302056b3d5bbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9cbcd4c017180e7d302056b3d5bbd4">&#9670;&nbsp;</a></span>evdns_base_resolve_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_request* evdns_base_resolve_reverse </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in_addr *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a PTR record for a given IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">in</td><td>an IPv4 address </td></tr>
    <tr><td class="paramname">flags</td><td>either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query. </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to invoke when the request is completed </td></tr>
    <tr><td class="paramname">ptr</td><td>an argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an evdns_request object if successful, or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns__compat_8h.html#a45bf87a8a77c7fba752836aab6a5a9cb" title="Lookup a PTR record for a given IPv6 address.">evdns_resolve_reverse_ipv6()</a>, <a class="el" href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef" title="Cancels a pending DNS resolution request.">evdns_cancel_request()</a> </dd></dl>

</div>
</div>
<a id="a55843d1e90512bfbe8499d52642240cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55843d1e90512bfbe8499d52642240cd">&#9670;&nbsp;</a></span>evdns_base_resolve_reverse_ipv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_request* evdns_base_resolve_reverse_ipv6 </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a43018959c4be1a9b16e4143c5e3ff556">evdns_callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a PTR record for a given IPv6 address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">in</td><td>an IPv6 address </td></tr>
    <tr><td class="paramname">flags</td><td>either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query. </td></tr>
    <tr><td class="paramname">callback</td><td>a callback function to invoke when the request is completed </td></tr>
    <tr><td class="paramname">ptr</td><td>an argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an evdns_request object if successful, or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns__compat_8h.html#a45bf87a8a77c7fba752836aab6a5a9cb" title="Lookup a PTR record for a given IPv6 address.">evdns_resolve_reverse_ipv6()</a>, <a class="el" href="dns_8h.html#a062bdd01f7243b3c8509d93c45a802ef" title="Cancels a pending DNS resolution request.">evdns_cancel_request()</a> </dd></dl>

</div>
</div>
<a id="a3ef3a20dd645e02d6dd5d3766ced9ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef3a20dd645e02d6dd5d3766ced9ce7">&#9670;&nbsp;</a></span>evdns_base_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_resume </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume normal operation and continue any suspended resolve requests. </p>
<p>Re-attempt resolves left in limbo after an earlier call to <a class="el" href="dns_8h.html#af942ce8b6a65052f4b6def91a3390a61" title="Remove all configured nameservers, and suspend all pending resolves.">evdns_base_clear_nameservers_and_suspend()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#af942ce8b6a65052f4b6def91a3390a61" title="Remove all configured nameservers, and suspend all pending resolves.">evdns_base_clear_nameservers_and_suspend()</a> </dd></dl>

</div>
</div>
<a id="a8044de93700190d5ca6a6a0becdc4f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8044de93700190d5ca6a6a0becdc4f6e">&#9670;&nbsp;</a></span>evdns_base_search_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_base_search_add </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a domain to the list of search domains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>the domain to be added to the search list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae858583b1c9fdd1f7c99330bcdd68ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae858583b1c9fdd1f7c99330bcdd68ba6">&#9670;&nbsp;</a></span>evdns_base_search_ndots_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_base_search_ndots_set </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the 'ndots' parameter for searches. </p>
<p>Sets the number of dots which, when found in a name, causes the first query to be without any search domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndots</td><td>the new ndots parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a791b6fdc9f41bd62414574d85ae18cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b6fdc9f41bd62414574d85ae18cc8">&#9670;&nbsp;</a></span>evdns_base_set_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evdns_base_set_option </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a configuration option. </p>
<p>The currently available configuration options are:</p>
<p>ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case, bind-to, initial-probe-timeout, getaddrinfo-allow-skew, so-rcvbuf, so-sndbuf.</p>
<p>In versions before Libevent 2.0.3-alpha, the option name needed to end with a colon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base to which to apply this operation </td></tr>
    <tr><td class="paramname">option</td><td>the name of the configuration option to be modified </td></tr>
    <tr><td class="paramname">val</td><td>the value to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a062bdd01f7243b3c8509d93c45a802ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062bdd01f7243b3c8509d93c45a802ef">&#9670;&nbsp;</a></span>evdns_cancel_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_cancel_request </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evdns_request *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels a pending DNS resolution request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the evdns_base that was used to make the request </td></tr>
    <tr><td class="paramname">req</td><td>the evdns_request that was returned by calling a resolve function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dns_8h.html#a4f8b11705fa285dffa661c7f55f86693" title="Lookup an A record for a given name.">evdns_base_resolve_ipv4()</a>, <a class="el" href="dns_8h.html#a646ca1414b09b9fec7763bf8aca05e74" title="Lookup an AAAA record for a given name.">evdns_base_resolve_ipv6</a>, <a class="el" href="dns_8h.html#a1f9cbcd4c017180e7d302056b3d5bbd4" title="Lookup a PTR record for a given IP address.">evdns_base_resolve_reverse</a> </dd></dl>

</div>
</div>
<a id="a24bb4cf48915f73e4e9c6d4b6216466b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bb4cf48915f73e4e9c6d4b6216466b">&#9670;&nbsp;</a></span>evdns_err_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const EVENT2_EXPORT_SYMBOL char* evdns_err_to_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DNS error code to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>the DNS error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing an explanation of the error code </dd></dl>

</div>
</div>
<a id="a28a4c5e6e22bcf92f8c229461023f914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a4c5e6e22bcf92f8c229461023f914">&#9670;&nbsp;</a></span>evdns_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evdns_getaddrinfo_request* evdns_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">struct evdns_base *&#160;</td>
          <td class="paramname"><em>dns_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>servname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&#160;</td>
          <td class="paramname"><em>hints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a0d1464f191ef7678be0d4caf3644a8f4">evdns_getaddrinfo_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a non-blocking getaddrinfo request using the dns_base in 'dns_base'. </p>
<p>If we can answer the request immediately (with an error or not!), then we invoke cb immediately and return NULL. Otherwise we return an evdns_getaddrinfo_request and invoke cb later.</p>
<p>When the callback is invoked, we pass as its first argument the error code that getaddrinfo would return (or 0 for no error). As its second argument, we pass the <a class="el" href="structevutil__addrinfo.html" title="A definition of struct addrinfo for systems that lack it.">evutil_addrinfo</a> structures we found (or NULL on error). We pass 'arg' as the third argument.</p>
<p>Limitations:</p>
<ul>
<li>The AI_V4MAPPED and AI_ALL flags are not currently implemented.</li>
<li>For ai_socktype, we only handle SOCKTYPE_STREAM, SOCKTYPE_UDP, and 0.</li>
<li>For ai_protocol, we only handle IPPROTO_TCP, IPPROTO_UDP, and 0. </li>
</ul>

</div>
</div>
<a id="a849622fc8fee97302a6a0a34e7e6feb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849622fc8fee97302a6a0a34e7e6feb8">&#9670;&nbsp;</a></span>evdns_server_request_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_server_request_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct evdns_server_request *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets some flags in a reply we're building. </p>
<p>Allows setting of the AA or RD flags </p>

</div>
</div>
<a id="af2ba90756cecdc246711879462a20b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ba90756cecdc246711879462a20b51">&#9670;&nbsp;</a></span>evdns_set_log_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_set_log_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dns_8h.html#a850904a1dbd8c8a087dc2be7617e21c8">evdns_debug_log_fn_type</a>&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function to handle DNS log messages. </p>
<p>If this callback is not set, evdns log messages are handled with the regular Libevent logging system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the callback to be invoked when a log message is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87cdd8e2c2fbdc2ba9685f11c2d229ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cdd8e2c2fbdc2ba9685f11c2d229ee">&#9670;&nbsp;</a></span>evdns_set_random_bytes_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_set_random_bytes_fn </td>
          <td>(</td>
          <td class="paramtype">void(*)(char *, size_t)&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback used to generate random bytes. </p>
<p>By default, we use the same function as passed to evdns_set_transaction_id_fn to generate bytes two at a time. If a function is provided here, it's also used to generate transaction IDs.</p>
<p>NOTE: This function has no effect in Libevent 2.0.4-alpha and later, since Libevent now provides its own secure RNG. </p>

</div>
</div>
<a id="a1e4c9dded0901a52eb2b92ed5a98e9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4c9dded0901a52eb2b92ed5a98e9bd">&#9670;&nbsp;</a></span>evdns_set_transaction_id_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evdns_set_transaction_id_fn </td>
          <td>(</td>
          <td class="paramtype">ev_uint16_t(*)(void)&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback that will be invoked to generate transaction IDs. </p>
<p>By default, we pick transaction IDs based on the current clock time, which is bad for security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the new callback, or NULL to use the default.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: This function has no effect in Libevent 2.0.4-alpha and later, since Libevent now provides its own secure RNG. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
