//
// Run:
// ./../../flatbuffers/flatc --cpp --gen-object-api ../monster.fbs
//

#include "monster_generated.h"

#include <iostream>
#include <vector>

using namespace MyGame::Sample;

uint8_t *serializeMonster1() {
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  flatbuffers::FlatBufferBuilder builder(1024);

  flatbuffers::Offset<flatbuffers::String> weaponOneName =
      builder.CreateString("Sword");
  short weaponOneDamage = 3;

  flatbuffers::Offset<flatbuffers::String> weaponTwoName =
      builder.CreateString("Axe");
  short weaponTwoDamage = 5;

  // Use the `CreateWeapon` shortcut to create Weapons with all the fields set.
  flatbuffers::Offset<Weapon> sword =
      CreateWeapon(builder, weaponOneName, weaponOneDamage);
  flatbuffers::Offset<Weapon> axe =
      CreateWeapon(builder, weaponTwoName, weaponTwoDamage);

  // Serialize a name for our monster, called "Orc".
  flatbuffers::Offset<flatbuffers::String> name = builder.CreateString("Orc");

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  unsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  flatbuffers::Offset<flatbuffers::Vector<unsigned char>> inventory =
      builder.CreateVector(treasure, 10);

  // Place the weapons into a `std::vector`, then convert that into a FlatBuffer
  // `vector`.
  std::vector<flatbuffers::Offset<Weapon>> weaponsVector;
  weaponsVector.push_back(sword);
  weaponsVector.push_back(axe);
  // NOTE: for vector of tables, we get a vector of offsets.
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Weapon>>>
      weapons = builder.CreateVector(weaponsVector);

  Vec3 points[] = {Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f)};
  // NOTE: for vector of structs, we get a vector of inline structs.
  flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> path =
      builder.CreateVectorOfStructs(points, 2);

  // Create the position struct.
  Vec3 position = Vec3(1.0f, 2.0f, 3.0f);

  // Set his hit points to 300 and his mana to 150.
  int hp = 300;
  int mana = 150;

  flatbuffers::Offset<Monster> orc =
      CreateMonster(builder,
                    // Note how we create Vec3 struct inline in the table.Unlike
                    // tables, structs are simple combinations of scalars that
                    // are always stored inline, just like scalars themselves.
                    &position, mana, hp, name, inventory, Color_Red, weapons,
                    Equipment_Weapon, axe.Union(), path);

  builder.Finish(orc);

  uint8_t *buf = builder.GetBufferPointer();
  int size = builder.GetSize();
  std::cout << "buf size = " << size << std::endl;
  return buf;
}

uint8_t *serializeMonster2() {
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  flatbuffers::FlatBufferBuilder builder(1024);

  flatbuffers::Offset<flatbuffers::String> weaponTwoName =
      builder.CreateString("Axe");
  short weaponTwoDamage = 5;
  flatbuffers::Offset<Weapon> axe =
      CreateWeapon(builder, weaponTwoName, weaponTwoDamage);

  MonsterBuilder monsterBuilder(builder);
  monsterBuilder.add_equipped_type(Equipment_Weapon);
  monsterBuilder.add_equipped(axe.Union());

  flatbuffers::Offset<Monster> orc = monsterBuilder.Finish();
  builder.Finish(orc);

  return builder.GetBufferPointer();
}

void deserializeMonster(uint8_t *buf) {
  const Monster *monster = GetMonster(buf);
  // The above is equivalent to:
  const Monster *monster2 = flatbuffers::GetRoot<Monster>(buf);

  auto hp = monster->hp();
  auto mana = monster->mana();
  auto name = monster->name()->c_str();
  std::cout << "monster hp = " << hp << ", mana = " << mana
            << ", name = " << name << std::endl;

  // Autogenerated class from table Monster.
  MonsterT *monsterT = monster->UnPack();
  std::cout << "monsterT hp = " << monsterT->hp << ", mana = " << monsterT->mana
            << ", name = " << monsterT->name << std::endl;
}

int main() {
  uint8_t *buf = serializeMonster1();
  deserializeMonster(buf);
}
